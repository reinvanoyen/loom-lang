{"version":3,"sources":["../src/tokenization/grammar.ts","../src/tokenization/Lexer.ts","../src/parser/Node.ts","../src/parser/nodes/IdentifierType.ts","../src/parser/nodes/StringType.ts","../src/parser/nodes/Type.ts","../src/parser/nodes/VariantDeclaration.ts","../src/parser/nodes/SlotDeclaration.ts","../src/parser/nodes/StyleBlock.ts","../src/context/Symbol.ts","../src/parser/nodes/Class.ts","../src/parser/nodes/TypeDeclaration.ts","../src/parser/nodes/Namespace.ts","../src/parser/nodes/ImportStatement.ts","../src/parser/AstNode.ts","../src/parser/Parser.ts","../src/compiler/Compiler.ts","../src/compiler/OutputBuffer.ts","../src/context/Binder.ts","../src/context/SymbolTable.ts","../src/analyzer/TypeResolver.ts","../src/analyzer/TypeTable.ts","../src/analyzer/DiagnosticsResult.ts","../src/analyzer/TypeChecker.ts","../src/Loom.ts"],"sourcesContent":["export default {\n    REGEX_IDENT: /\\p{L}/u,\n    REGEX_RAW_BLOCK_START: /{/,\n    REGEX_RAW_BLOCK_END: /}/,\n    REGEX_RAW_BLOCK_INSIDE: /%/,\n    REGEX_NUMBER: /\\d/,\n    REGEX_SYMBOL: /[.!?,;:()\\-+=%*\\\\/—–…${}><&#@°|]/,\n    REGEX_WHITESPACE: /\\s/,\n    REGEX_NEWLINE: /[\\n\\r]/,\n    REGEX_STRING_DELIMITER: /[\"']/,\n    STRING_ESCAPE_SYMBOL: '\\\\',\n};","import grammar from './grammar';\nimport { LexMode, TokenStream, TokenType } from '../types/tokenization';\n\nexport default class Lexer {\n    /**\n     * The source code to tokenize\n     * @private\n     */\n    private source: string;\n\n    /**\n     * The current mode of lexing\n     * @private\n     */\n    private mode: LexMode = LexMode.ALL;\n\n    /**\n     * The current position of the cursor\n     * @private\n     */\n    private cursor: number = 0;\n\n    /**\n     * The position of the cursor at the start of the mode\n     * @private\n     */\n    private modeStartCursor: number = 0;\n\n    /**\n     * The current line, starting at line 1\n     * @private\n     */\n    private line: number = 1;\n\n    /**\n     * The current position on the current line, starting at 1\n     * @private\n     */\n    private column: number = 1;\n\n    /**\n     * The current character\n     * @private\n     */\n    private character: string = '';\n\n    /**\n     * The next character, handy for simple look-ahead\n     * @private\n     */\n    private nextCharacter: string = '';\n\n    /**\n     * The index of the last character, also the amount of characters\n     * @private\n     */\n    private end: number = 0;\n\n    /**\n     * The current token stream being created\n     * @private\n     */\n    private tokens: TokenStream = [];\n\n    /**\n     * The current value being lexed\n     * @private\n     */\n    private value: string = '';\n\n    /**\n     * The current delimiter (e.g. string delimiter or boundary)\n     * @private\n     */\n    private delimiter: string = ''\n\n    /**\n     * Transforms code into a TokenStream\n     * @param text\n     */\n    tokenize(text: string): TokenStream {\n\n        this.source = text;\n        this.end = this.source.length;\n\n        while (this.cursor < this.end) {\n\n            this.character = this.source[this.cursor];\n            this.nextCharacter = this.source[this.cursor+1] || null;\n\n            // Determine the mode\n            if (this.mode === LexMode.ALL) {\n                this.mode = this.determineMode();\n                this.modeStartCursor = this.cursor;\n            }\n\n            switch (this.mode) {\n                case LexMode.STRING:\n                    this.lexString();\n                    break;\n                case LexMode.IDENT:\n                    this.lexIdent();\n                    break;\n                case LexMode.RAW_BLOCK:\n                    this.lexRawBlock();\n                    break;\n                case LexMode.NUMBER:\n                    this.lexNumber();\n                    break;\n                case LexMode.SYMBOL:\n                    this.lexSymbol();\n                    break;\n                case LexMode.NEWLINE:\n                    this.lexNewline();\n                    break;\n                case LexMode.WHITESPACE:\n                    this.lexWhitespace();\n                    break;\n                case LexMode.UNKNOWN:\n                    this.lexUnknown();\n                    break;\n            }\n        }\n\n        return this.tokens;\n    }\n\n    /**\n     * @private\n     */\n    private atEnd(accountForDelimiter: boolean = false): boolean {\n        const offset = accountForDelimiter ? 1 : 0;\n        return this.cursor + offset >= this.end;\n    }\n\n    /**\n     * Determines the lexing mode based on the current character\n     * @private\n     */\n    private determineMode(): LexMode {\n\n        // Reset the current token value\n        this.value = '';\n\n        if (\n            grammar.REGEX_RAW_BLOCK_START.exec(this.character) &&\n            grammar.REGEX_RAW_BLOCK_INSIDE.exec(this.nextCharacter)\n        ) {\n            return LexMode.RAW_BLOCK;\n        }\n\n        if (grammar.REGEX_IDENT.exec(this.character)) {\n            return LexMode.IDENT;\n        }\n\n        if (grammar.REGEX_STRING_DELIMITER.exec(this.character)) {\n            this.delimiter = this.character;\n            return LexMode.STRING;\n        }\n\n        if (grammar.REGEX_NUMBER.exec(this.character)) {\n            return LexMode.NUMBER;\n        }\n\n        if (grammar.REGEX_SYMBOL.exec(this.character)) {\n            return LexMode.SYMBOL;\n        }\n\n        if (grammar.REGEX_NEWLINE.exec(this.character)) {\n            return LexMode.NEWLINE;\n        }\n\n        if (grammar.REGEX_WHITESPACE.exec(this.character)) {\n            return LexMode.WHITESPACE;\n        }\n\n        return LexMode.UNKNOWN;\n    }\n\n    /**\n     * Tokenize string\n     * @private\n     */\n    private lexString() {\n\n        const escSequence = (this.character === grammar.STRING_ESCAPE_SYMBOL);\n\n        // String escaping\n        if (escSequence) {\n            this.cursor += 1;\n            // We directly alter the character and nextCharacter,\n            // so we can directly consume them further down in the method\n            this.character = this.source[this.cursor];\n            this.nextCharacter = this.source[this.cursor + 1] || null;\n        }\n\n        if (this.character !== this.delimiter || escSequence) {\n            // Consume the character\n            this.value += this.character;\n        }\n\n        this.cursor++;\n\n        if (this.nextCharacter === this.delimiter) {\n            this.tokens.push({\n                type: TokenType.STRING,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(true),\n            });\n            this.cursor++;\n            this.column += this.cursor - this.modeStartCursor;\n            this.mode = LexMode.ALL;\n            this.delimiter = '';\n        }\n    }\n\n    /**\n     * Tokenize raw block\n     * @private\n     */\n    private lexRawBlock() {\n\n        // If we just entered raw block, skip the opening \"{%\"\n        if (\n            this.value.length === 0 &&\n            grammar.REGEX_RAW_BLOCK_START.exec(this.character) &&      // '{'\n            grammar.REGEX_RAW_BLOCK_INSIDE.exec(this.nextCharacter)    // '%'\n        ) {\n            this.cursor += 2;\n            this.column += 2;\n            return;\n        }\n\n        if (\n            grammar.REGEX_RAW_BLOCK_INSIDE.exec(this.character) &&\n            grammar.REGEX_RAW_BLOCK_END.exec(this.nextCharacter)\n        ) {\n            this.tokens.push({\n                type: TokenType.RAW_BLOCK,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.cursor += 2;\n            this.column += 2;\n            this.mode = LexMode.ALL;\n            return;\n        }\n\n        this.value += this.character;\n        this.cursor++;\n        this.column++;\n    }\n\n    /**\n     * Tokenize identifier\n     * @private\n     */\n    private lexIdent() {\n\n        this.value += this.character;\n        this.cursor++;\n\n        if (! this.nextCharacter || ! grammar.REGEX_IDENT.exec(this.nextCharacter)) {\n            this.tokens.push({\n                type: TokenType.IDENT,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.column += this.value.length;\n            this.mode = LexMode.ALL;\n        }\n    }\n\n    /**\n     * Tokenize number\n     * @private\n     */\n    private lexNumber() {\n        this.value += this.character;\n        this.cursor++;\n\n        if (!this.nextCharacter || !grammar.REGEX_NUMBER.exec(this.nextCharacter)) {\n            this.tokens.push({\n                type: TokenType.NUMBER,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.column += this.cursor - this.modeStartCursor;\n            this.mode = LexMode.ALL;\n        }\n    }\n\n    /**\n     * Tokenize symbol\n     * @private\n     */\n    private lexSymbol() {\n\n        this.cursor++;\n\n        this.tokens.push({\n            type: TokenType.SYMBOL,\n            value: this.character,\n            line: this.line,\n            position: this.column,\n            end: this.atEnd(),\n        });\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n\n    /**\n     * Tokenize newline\n     * @private\n     */\n    private lexNewline() {\n        this.cursor++;\n        this.line++;\n        this.column = 1;\n        this.mode = LexMode.ALL;\n    }\n\n    /**\n     * Tokenize whitespace\n     * @private\n     */\n    private lexWhitespace() {\n        this.cursor++;\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n\n    /**\n     * Tokenize unknown\n     * @private\n     */\n    private lexUnknown() {\n        this.tokens.push({\n            type: TokenType.UNKNOWN,\n            value: this.character,\n            line: this.line,\n            position: this.column,\n            end: this.atEnd(),\n        });\n        this.cursor++;\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n}","import { Nullable } from '../types/nullable';\nimport { AttributeValue } from '../types/attribute';\nimport Parser from './Parser';\nimport Symbol from '../context/Symbol';\nimport Compiler from '../compiler/Compiler';\nimport Binder from '../context/Binder';\nimport TypeResolver from '../analyzer/TypeResolver';\nimport TypeChecker from '../analyzer/TypeChecker';\nimport TypeTable from '../analyzer/TypeTable';\n\nexport default class Node {\n\n    /**\n     * @protected\n     */\n    private id: Nullable<number> = null;\n\n    /**\n     * @private\n     */\n    private symbol: Nullable<Symbol> = null;\n\n    /**\n     *\n     * @protected\n     */\n    protected value: string;\n\n    /**\n     *\n     * @protected\n     */\n    protected parent: Nullable<Node> = null;\n\n    /**\n     *\n     * @protected\n     */\n    protected children: Node[] = [];\n\n    /**\n     *\n     * @protected\n     */\n    protected attributes: Record<string, AttributeValue> = {};\n\n    /**\n     *\n     * @param value\n     */\n    constructor(value: string = '') {\n        this.value = value;\n    }\n\n    /**\n     * @param id\n     */\n    setId(id: number) {\n        this.id = id;\n    }\n\n    /**\n     *\n     */\n    getId(): Nullable<number> {\n        return this.id;\n    }\n\n    /**\n     * @param symbol\n     */\n    setSymbol(symbol: Symbol) {\n        this.symbol = symbol;\n    }\n\n    /**\n     *\n     */\n    getSymbol() {\n        return this.symbol;\n    }\n\n    /**\n     *\n     */\n    getName(): string {\n        return this.constructor.name;\n    }\n\n    /**\n     *\n     * @param node\n     */\n    setParent(node: Node) {\n        this.parent = node;\n    }\n\n    /**\n     *\n     */\n    getParent(): Node {\n        return this.parent;\n    }\n\n    /**\n     *\n     */\n    getValue(): string {\n        return this.value;\n    }\n\n    /**\n     *\n     * @param value\n     */\n    setValue(value: string) {\n        this.value = value;\n    }\n\n    /**\n     *\n     * @param node\n     */\n    addChild(node: Node) {\n        this.children.push(node);\n    }\n\n    /**\n     *\n     */\n    getChildren() {\n        return this.children;\n    }\n\n    /**\n     *\n     */\n    hasChildren() {\n        return (this.children.length > 0);\n    }\n\n    /**\n     *\n     * @param name\n     * @param value\n     */\n    setAttribute(name: string, value: AttributeValue) {\n        this.attributes[name] = value;\n    }\n\n    /**\n     *\n     * @param name\n     */\n    getAttribute(name: string): Nullable<AttributeValue> {\n        return this.attributes[name] || null;\n    }\n\n    /**\n     *\n     */\n    getAttributes(): Record<string, AttributeValue> {\n        return this.attributes;\n    }\n\n    /**\n     *\n     */\n    removeLastChild() {\n        this.children.pop();\n    }\n\n    /**\n     *\n     * @param _parser\n     */\n    parse(_parser: Parser): boolean {\n        return false;\n    }\n\n    /**\n     *\n     * @param _compiler\n     */\n    compile(compiler: Compiler) {\n        // todo\n    }\n\n    bind(binder: Binder) {\n        this.getChildren().forEach(child => {\n            child.bind(binder);\n        });\n    }\n\n    resolve(typeResolver: TypeResolver) {\n        this.getChildren().forEach(child => {\n            child.resolve(typeResolver);\n        });\n    }\n\n    check(typeChecker: TypeChecker, typeTable: TypeTable) {\n        this.getChildren().forEach(child => {\n            child.check(typeChecker, typeTable);\n        });\n    }\n\n    print(): string {\n\n        const printNode = (node: Node, indentAmount: number = 0): string => {\n\n            const nodeName = `${node.getId()} – ${node.getName()}`;\n            const nodeValue = node.getValue();\n\n            const attributes = node.getAttributes();\n            const attributesString = [];\n            for (const attribute in attributes) {\n                let attrValue = attributes[attribute];\n                if (attrValue instanceof Node) {\n                    const attrNodeValue = attrValue.getValue();\n                    attrValue = `${attrValue.getName()}${attrNodeValue ? `(${attrNodeValue})` : ''}`;\n                }\n                attributesString.push(`${attribute}=${attrValue}`);\n            }\n\n            const tabs = indentAmount > 0 ? '   '.repeat(indentAmount - 1) + '└──' : '';\n            const output = [`${tabs}${nodeName}${nodeValue ? `(${nodeValue})` : ''} ${attributesString.join(' ')}`];\n\n            node.getChildren().forEach(childNode => {\n                output.push(printNode(childNode, indentAmount + 1));\n            });\n\n            return output.join('\\n');\n        };\n\n        return printNode(this);\n    }\n}","import Node from '../Node';\nimport Binder from '../../context/Binder';\n\nexport default class IdentifierType extends Node {\n\n    bind(binder: Binder) {\n        if (this.getValue() !== 'string') {\n            this.setSymbol(binder.getType(this.getValue()));\n        }\n    }\n\n    compile() {\n        // todo compile TypeIdentNode\n    }\n}","import Node from '../Node';\n\nexport default class StringType extends Node {\n\n    compile() {\n        // todo compile TypeIdentNode\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport IdentifierType from './IdentifierType';\nimport StringType from './StringType';\nimport Binder from '../../context/Binder';\n\nexport default class Type extends Node {\n    /**\n     * @param parser\n     */\n    static parse(parser: Parser): boolean {\n\n        parser.expectOneOf([TokenType.IDENT, TokenType.STRING]);\n\n        parser.insert(new Type());\n        parser.in();\n\n        if (this.parseUnionType(parser)) {\n            parser.out();\n            return true;\n        }\n\n        return false;\n    }\n\n    private static parseType(parser: Parser) {\n        if (parser.accept(TokenType.IDENT)) {\n            parser.insert(new IdentifierType(parser.getCurrentValue()))\n            parser.advance();\n            return true;\n        }\n\n        if (parser.accept(TokenType.STRING)) {\n            parser.insert(new StringType(parser.getCurrentValue()))\n            parser.advance();\n            return true;\n        }\n\n        return false;\n    }\n\n    private static parseUnionType(parser: Parser) {\n        if (this.parseType(parser)) {\n            if (parser.skipWithValue(TokenType.SYMBOL, '|')) {\n                this.parseUnionType(parser);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    bind(binder: Binder) {\n        this.getChildren().forEach(child => {\n            child.bind(binder);\n        });\n    }\n\n    compile() {\n        // todo compile VariantDefinition\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport Type from './Type';\nimport TypeChecker from '../../analyzer/TypeChecker';\nimport TypeTable from '../../analyzer/TypeTable';\n\nexport default class VariantDeclaration extends Node {\n    /**\n     * @param parser\n     */\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.SYMBOL,'@')) {\n            parser.expect(TokenType.IDENT);\n            parser.insert(new VariantDeclaration());\n            parser.in();\n            parser.setAttribute('name', parser.getCurrentValue());\n            parser.advance();\n\n            parser.expectWithValue(TokenType.SYMBOL, ':');\n            parser.advance();\n\n            Type.parse(parser);\n            parser.setAttribute('type');\n\n            // Parse default value\n            if (parser.skipWithValue(TokenType.SYMBOL, '=')) {\n                parser.expect(TokenType.STRING);\n                parser.setAttribute('default', parser.getCurrentValue());\n                parser.advance();\n            }\n\n            parser.out();\n            parser.expectWithValue(TokenType.SYMBOL, ';');\n            parser.advance();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    check(typeChecker: TypeChecker, typeTable: TypeTable) {\n        //typeChecker.isAssignable(typeTable.getType(this.getAttribute('name')))\n        //console.log(this.getAttribute('default'), typeTable.getType());\n    }\n\n    compile() {\n        // todo compile VariantDefinition\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport Compiler from '../../compiler/Compiler';\n\nexport default class SlotDeclaration extends Node {\n    /**\n     * @param parser\n     */\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.IDENT,'slot')) {\n            parser.expect(TokenType.IDENT);\n            parser.insert(new SlotDeclaration(parser.getCurrentValue()));\n            parser.advance();\n\n            parser.expectWithValue(TokenType.SYMBOL, ';');\n            parser.advance();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        // todo - register the slot on runtime\n        //compiler.writeLine(`.${this.getValue()} {}`);\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport Compiler from '../../compiler/Compiler';\n\nexport default class StyleBlock extends Node {\n    /**\n     * @param parser\n     */\n    static parse(parser: Parser): boolean {\n        if (parser.accept(TokenType.RAW_BLOCK)) {\n            parser.insert(new StyleBlock());\n            parser.in();\n            parser.setAttribute('contents', parser.getCurrentValue());\n            parser.advance();\n            parser.out();\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        const contents = this.getAttribute('contents');\n\n        if (typeof contents === 'string') {\n            compiler.writeLine('\\t'+contents.trim());\n        }\n    }\n}","import { Namespace } from '../types/namespace';\n\nexport type SymbolType = 'namespace' | 'class' | 'type' | 'variant' | 'slot';\n\nlet currentId = 0;\n\nexport default class Symbol {\n    /**\n     * @private\n     */\n    private readonly id: number;\n\n    /**\n     * @private\n     */\n    private type: SymbolType;\n\n    /**\n     * @private\n     */\n    private nodeId: number;\n\n    /**\n     * @private\n     */\n    private namespace: Namespace;\n\n    /**\n     * @param type\n     * @param nodeId\n     */\n    constructor(type: SymbolType, nodeId: number) {\n        this.id = currentId++;\n        this.type = type;\n        this.nodeId = nodeId;\n    }\n\n    /**\n     */\n    getId(): number {\n        return this.id;\n    }\n\n    /**\n     * @param ns\n     */\n    setNamespace(ns: Namespace) {\n        this.namespace = ns;\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport VariantDeclaration from './VariantDeclaration';\nimport SlotDeclaration from './SlotDeclaration';\nimport StyleBlock from './StyleBlock';\nimport Binder from '../../context/Binder';\nimport Compiler from '../../compiler/Compiler';\nimport Symbol from '../../context/Symbol';\nimport TypeResolver from '../../analyzer/TypeResolver';\n\nexport default class Class extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.IDENT, 'class')) {\n\n            if (parser.expect(TokenType.IDENT)) {\n                parser.insert(new Class(parser.getCurrentValue()));\n                parser.traverseUp();\n                parser.advance();\n            }\n\n            if (parser.skipWithValue(TokenType.IDENT, 'extends')) {\n                parser.expect(TokenType.IDENT);\n                parser.setAttribute('extends', parser.getCurrentValue());\n                parser.advance();\n            }\n\n            parser.expectWithValue(TokenType.SYMBOL, '{');\n            parser.advance();\n\n            // Parse class body\n            while(\n                VariantDeclaration.parse(parser) ||\n                SlotDeclaration.parse(parser) ||\n                StyleBlock.parse(parser)\n            );\n\n            if (parser.expectWithValue(TokenType.SYMBOL, '}')) {\n                parser.out();\n                parser.advance();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    bind(binder: Binder) {\n        this.setSymbol(new Symbol('class', this.getId()));\n        binder.add(this.getValue(), this.getSymbol());\n    }\n\n    resolve(typeResolver: TypeResolver) {\n        this.getChildren().forEach(child => {\n            child.resolve(typeResolver);\n        });\n    }\n\n    compile(compiler: Compiler) {\n\n        /*\n        // Get current namespace\n        const namespace = compiler.symbols().getNamespace();\n\n        // Build classname\n        const className = `${namespace ? namespace+'-' : '' }${this.getValue()}`;\n\n        // Write CSS :)\n        compiler.writeLine(`.${className} {`);\n\n        this.getChildren().forEach(child => {\n            child.compile(compiler);\n        });\n\n        compiler.writeLine('}');\n        */\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport Type from './Type';\nimport Compiler from '../../compiler/Compiler';\nimport Binder from '../../context/Binder';\nimport Symbol from '../../context/Symbol';\nimport TypeResolver from '../../analyzer/TypeResolver';\n\nexport default class TypeDeclaration extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.IDENT, 'type')) {\n            parser.expect(TokenType.IDENT);\n            parser.insert(new TypeDeclaration(parser.getCurrentValue()));\n            parser.in();\n            parser.advance();\n            \n            parser.expectWithValue(TokenType.SYMBOL, '=');\n            parser.advance();\n\n            Type.parse(parser);\n\n            parser.out();\n            parser.expectWithValue(TokenType.SYMBOL, ';');\n            parser.advance();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    bind(binder: Binder) {\n        this.setSymbol(new Symbol('type', this.getId()));\n        binder.addType(this.getValue(), this.getSymbol());\n\n        this.getChildren().forEach(child => child.bind(binder));\n    }\n\n    resolve(typeResolver: TypeResolver) {\n\n        const rhs = this.getChildren().find(child => child instanceof Type) as Type | undefined;\n\n        if (!rhs) {\n            throw new Error(`TypeResolver error: missing RHS type for '${this.getValue()}'`);\n        }\n\n        typeResolver.defineType(this.getSymbol(), typeResolver.resolveType(rhs));\n    }\n\n    compile(compiler: Compiler) {\n        //\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport Compiler from '../../compiler/Compiler';\nimport Binder from '../../context/Binder';\nimport TypeResolver from '../../analyzer/TypeResolver';\n\nexport default class Namespace extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.IDENT, 'namespace')) {\n            parser.expect(TokenType.IDENT);\n            parser.insert(new Namespace(parser.getCurrentValue()));\n            parser.advance();\n\n            parser.expectWithValue(TokenType.SYMBOL, ';');\n            parser.advance();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    bind(binder: Binder) {\n        binder.namespace(this.getValue());\n    }\n\n    resolve(typeResolver: TypeResolver) {\n        //typeResolver.namespace(this.getValue());\n    }\n\n    compile(compiler: Compiler) {\n        //compiler.symbols().setNamespace(this.getValue());\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport Compiler from '../../compiler/Compiler';\n\nexport default class ImportStatement extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.IDENT, 'import')) {\n            parser.expect(TokenType.STRING);\n            parser.insert(new ImportStatement(parser.getCurrentValue()));\n            parser.advance();\n\n            parser.expectWithValue(TokenType.SYMBOL, ';');\n            parser.advance();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        // Import\n    }\n}","import Node from './Node';\nimport Parser from './Parser';\nimport Class from './nodes/Class';\nimport TypeDeclaration from './nodes/TypeDeclaration';\nimport Namespace from './nodes/Namespace';\nimport Compiler from '../compiler/Compiler';\nimport ImportStatement from './nodes/ImportStatement';\nimport Binder from '../context/Binder';\nimport TypeResolver from '../analyzer/TypeResolver';\n\nexport default class AstNode extends Node {\n\n    static parse(parser: Parser): boolean {\n        \n        while(\n            Namespace.parse(parser) ||\n            ImportStatement.parse(parser) ||\n            TypeDeclaration.parse(parser) ||\n            Class.parse(parser)\n        );\n\n        return true;\n    }\n\n    compile(compiler: Compiler) {\n        this.getChildren().forEach(child => {\n            child.compile(compiler);\n        });\n    }\n\n    bind(binder: Binder) {\n        this.getChildren().forEach(child => {\n            child.bind(binder);\n        });\n    }\n\n    resolve(typeResolver: TypeResolver) {\n        this.getChildren().forEach(child => {\n            child.resolve(typeResolver);\n        });\n    }\n}","import { Token, TokenStream, TokenType } from '../types/tokenization';\nimport AstNode from './AstNode';\nimport Node from './Node';\nimport { Nullable } from '../types/nullable';\n\nexport default class Parser {\n\n    /**\n     * The current id\n     * @private\n     */\n    private currentId: number = 0;\n\n    /**\n     * The current position of the cursor\n     * @private\n     */\n    private cursor: number = 0;\n\n    /**\n     * The TokenStream currently being parsed (input)\n     * @private\n     */\n    private tokens: TokenStream;\n\n    /**\n     * The Abstract Syntax Tree (AST) currently being build (output)\n     * @private\n     */\n    private ast: AstNode = new AstNode();\n\n    /**\n     * The current scope, which is the Node in which we're currently parser\n     * @private\n     */\n    private scope: Node = this.ast;\n\n    /**\n     * Parse a TokenStream into an Abstract Syntax Tree (AST)\n     * @param tokens\n     */\n    public parse(tokens: TokenStream): AstNode {\n\n        this.setTokenStream(tokens);\n        this.parseAll();\n\n        return this.ast;\n    }\n\n    /**\n     * Set the TokenStream\n     * @param tokens\n     */\n    public setTokenStream(tokens: TokenStream) {\n        this.tokens = tokens;\n    }\n\n    /**\n     * Parse all tokens in the TokenStream, starting from the cursor position\n     */\n    private parseAll() {\n\n        if (! this.tokens.length) {\n            return;\n        }\n\n        if (this.cursor > (this.tokens.length-1)) {\n            return;\n        }\n\n        if (AstNode.parse(this)) {\n            this.parseAll();\n        }\n    }\n\n    /**\n     * Get the Token at the cursor position\n     */\n    public getCurrentToken(): Token {\n        return this.tokens[this.cursor];\n    }\n\n    /**\n     * Get the Token at the offset of the cursor position\n     * @param offset\n     */\n    private getOffsetToken(offset: number): Token {\n        return this.tokens[this.cursor + offset];\n    }\n\n    /**\n     * Set a value as attribute to the current scope Node\n     * If no explicit value was given, the last inserted Node will be used as value\n     * @param name\n     * @param value\n     */\n    public setAttribute(name: string, value: Nullable<string | Node> = null) {\n        if (value === null) {\n            value = this.getLastNode();\n            this.getScope().removeLastChild();\n        }\n        this.getScope().setAttribute(name, value);\n    }\n\n    /**\n     * Get the value of the current token\n     */\n    public getCurrentValue(): string {\n        return this.getCurrentToken().value;\n    }\n\n    /**\n     * Advance the cursor position by a certain offset\n     * @param offset\n     */\n    public advance(offset: number = 1) {\n        this.cursor = this.cursor + offset;\n    }\n\n    /**\n     * Accept a token of the given type at this cursor position\n     * @param type\n     */\n    public accept(type: TokenType): boolean {\n        const token = this.getCurrentToken();\n        return (token && token.type === type);\n    }\n\n    /**\n     * Accept a token of the given type and with given value at this cursor position\n     * @param type\n     * @param value\n     */\n    public acceptWithValue(type: TokenType, value: string): boolean {\n        const token = this.getCurrentToken();\n        return (\n            token &&\n            token.type === type &&\n            token.value === value\n        );\n    }\n\n    /**\n     * Accept a token of the given type at the given offset of this cursor position\n     * @param type\n     * @param offset\n     */\n    public acceptAt(type: TokenType, offset: number): boolean {\n        const token = this.getOffsetToken(offset);\n        return (token && token.type === type);\n    }\n\n    /**\n     * Accept a token of the given type and with given value at the given offset of this cursor position\n     * @param type\n     * @param offset\n     * @param value\n     */\n    public acceptAtWithValue(type: TokenType, offset: number, value: string): boolean {\n        const token = this.getOffsetToken(offset);\n        return (\n            token &&\n            token.type === type &&\n            token.value === value\n        );\n    }\n\n    /**\n     * @param types\n     */\n    public acceptOneOf(types: TokenType[]): boolean {\n        const token = this.getCurrentToken();\n        return (token && types.includes(token.type));\n    }\n\n    /**\n     * Skip a token of the given type at this cursor position\n     * @param type\n     */\n    public skip(type: TokenType): boolean {\n        if (this.accept(type)) {\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Skip the token at this cursor position if it's of the given type and has the given value\n     * @param type\n     * @param value\n     */\n    public skipWithValue(type: TokenType, value: string): boolean {\n        if (this.acceptWithValue(type, value)) {\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Expect a token of the given type at this cursor position\n     * @param type\n     */\n    public expect(type: TokenType): boolean {\n        if (this.accept(type)) {\n            return true;\n        }\n        throw new Error('Unexpected token');\n        // todo implement UnexpectedToken error\n        //throw new UnexpectedToken(type, this.getCurrentToken());\n    }\n\n    /**\n     * Expect a token of the given type with give value at this cursor position\n     * @param type\n     * @param value\n     */\n    public expectWithValue(type: TokenType, value: string): boolean {\n        if (this.acceptWithValue(type, value)) {\n            return true;\n        }\n        throw new Error(`Unexpected token, expected ${type} with value ${value} got ${this.getCurrentToken().type} ${this.getCurrentToken().value}`);\n        // todo implement UnexpectedToken error\n        //throw new UnexpectedToken(type, this.getCurrentToken());\n    }\n\n    /**\n     * Expect a token of the given type and with given value at the given offset of this cursor position\n     * @param type\n     * @param offset\n     * @param value\n     */\n    public expectAtWithValue(type: TokenType, offset: number, value: string): boolean {\n        if (this.acceptAtWithValue(type, offset, value)) {\n            return true;\n        }\n        throw new Error('Unexpected token');\n        // todo implement UnexpectedToken error\n        //throw new UnexpectedToken(type, this.getCurrentToken());\n    }\n\n    /**\n     *\n     * @param types\n     */\n    public expectOneOf(types: TokenType[]): boolean {\n        if (this.acceptOneOf(types)) {\n            return true;\n        }\n        throw new Error('Unexpected token, expected one of: '+types.join(', '));\n        // todo implement UnexpectedToken error\n        //throw new UnexpectedToken(type, this.getCurrentToken());\n    }\n\n    /**\n     * Point the scope to the last inserted Node\n     */\n    public in() {\n        this.setScope(this.getLastNode());\n    }\n\n    /**\n     * Point the scope to the parent of the current scope\n     */\n    public out() {\n        this.setScope(this.getScope().getParent());\n    }\n\n    /**\n     * Alias of in()\n     */\n    public traverseUp() {\n        this.in();\n    }\n\n    /**\n     * Alias of out()\n     */\n    public traverseDown() {\n        this.out();\n    }\n\n    /**\n     * Get the current scope Node\n     */\n    public getScope(): Node {\n        return this.scope;\n    }\n\n    /**\n     * Get the last inserted Node\n     */\n    public getLastNode(): Node {\n        return this.scope.getChildren()[this.scope.getChildren().length-1];\n    }\n\n    /**\n     * Insert a Node into the current scope\n     * @param node\n     */\n    public insert(node: Node) {\n        this.assignNewId(node);\n        node.setParent(this.scope);\n        this.scope.addChild(node);\n    }\n\n    /**\n     * @param node\n     * @private\n     */\n    private assignNewId(node: Node) {\n        this.currentId++;\n        node.setId(this.currentId);\n\n    }\n\n    /**\n     * Set the current scope\n     * @param node\n     */\n    private setScope(node: Node) {\n        this.scope = node;\n    }\n\n    /**\n     * Wrap the last inserted Node with another Node, the scope will be the wrapping Node\n     * @param node\n     */\n    public wrap(node: Node) {\n        const last = this.getLastNode();\n        this.getScope().removeLastChild();\n\n        this.insert(node);\n        this.traverseUp();\n\n        this.insert(last);\n    }\n\n    /**\n     * Get the built Abstract Syntax Tree (AST)\n     */\n    public getAst(): AstNode {\n        return this.ast;\n    }\n}","import Node from '../parser/Node';\nimport OutputBuffer from './OutputBuffer';\nimport SymbolTable from '../context/SymbolTable';\n\nexport default class Compiler {\n    /**\n     * @private\n     */\n    private readonly symbolTable: SymbolTable;\n\n    /**\n     * @private\n     */\n    private readonly buffer: OutputBuffer;\n\n    /**\n     *\n     */\n    constructor(outputBuffer: OutputBuffer) {\n        this.buffer = outputBuffer;\n    }\n\n    /**\n     *\n     */\n    public symbols(): SymbolTable {\n        return this.symbolTable;\n    }\n\n    /**\n     *\n     * @param string\n     */\n    write(string: string) {\n        this.buffer.writeBody(string);\n    }\n\n    writeLine(string: string) {\n        this.buffer.writeBody('\\n'+string);\n    }\n\n    compile(ast: Node) {\n        ast.compile(this);\n        return this.buffer.render();\n    }\n}","export default class OutputBuffer {\n\n    /**\n     *\n     * @private\n     */\n    private head: string[] = [];\n\n    /**\n     *\n     * @private\n     */\n    private body: string[] = [];\n\n    /**\n     *\n     * @private\n     */\n    private foot: string[] = [];\n\n    /**\n     *\n     * @param string\n     */\n    writeBody(string: string) {\n        this.body.push(string);\n    }\n\n    /**\n     *\n     * @param string\n     */\n    writeHead(string: string) {\n        this.head.push(string);\n    }\n\n    /**\n     *\n     * @param string\n     */\n    writeFoot(string: string) {\n        this.foot.push(string);\n    }\n\n    /**\n     *\n     */\n    getHead(): string {\n        return this.head.join('');\n    }\n\n    /**\n     *\n     */\n    getBody(): string {\n        return this.body.join('');\n    }\n\n    /**\n     *\n     */\n    getFoot(): string {\n        return this.foot.join('');\n    }\n\n    render(): string {\n        return this.getHead()+this.getBody()+this.getFoot();\n    }\n}","import Node from '../parser/Node';\nimport Symbol from './Symbol';\nimport SymbolTable from '../context/SymbolTable';\nimport { Namespace } from '../types/namespace';\n\nexport default class Binder {\n    /**\n     * @private\n     */\n    private symbolTable: SymbolTable;\n\n    /**\n     * @private\n     */\n    private currentNamespace: Namespace = 'global';\n\n    /**\n     * @param symbolTable\n     */\n    constructor(symbolTable: SymbolTable) {\n        this.symbolTable = symbolTable;\n    }\n\n    /**\n     * @param ast\n     */\n    bind(ast: Node) {\n        ast.bind(this);\n    }\n\n    /**\n     * @param ns\n     */\n    namespace(ns: Namespace) {\n        this.currentNamespace = ns;\n    }\n\n    /**\n     * @param name\n     * @param symbol\n     */\n    add(name: string, symbol: Symbol) {\n        if (this.symbolTable.hasSymbol(this.currentNamespace, name)) {\n            throw new Error(`Binding error: ${name} already exists`);\n        }\n        this.symbolTable.registerSymbol(this.currentNamespace, name, symbol);\n    }\n\n    /**\n     * @param name\n     */\n    get(name: string) {\n        if (!this.symbolTable.hasSymbol(this.currentNamespace, name)) {\n            throw new Error(`Binding error: couldn't get symbol with name ${name}`);\n        }\n        return this.symbolTable.getSymbol(this.currentNamespace, name);\n    }\n\n    // GLOBAL TYPE SPACE\n    addType(name: string, symbol: Symbol) {\n        if (this.symbolTable.hasType(name)) {\n            throw new Error(`Binding error: type '${name}' already exists`);\n        }\n        // optional metadata:\n        symbol.setNamespace('global'); // or store declaredNamespace separately\n        this.symbolTable.registerType(name, symbol);\n    }\n\n    getType(name: string) {\n        return this.symbolTable.getType(name);\n    }\n}","import { Namespace } from '../types/namespace';\nimport Symbol from '../context/Symbol';\n\nexport default class SymbolTable {\n    private symbols: Record<Namespace, Record<string, Symbol>> = {};\n    private types: Record<string, Symbol> = {}; // global type space\n\n    // --- types (global) ---\n    public registerType(name: string, symbol: Symbol) {\n        this.types[name] = symbol;\n    }\n\n    public hasType(name: string) {\n        return typeof this.types[name] !== 'undefined';\n    }\n\n    public getType(name: string): Symbol | null {\n        return this.types[name] ?? null;\n    }\n\n    // --- values/classes (namespaced) ---\n    public registerSymbol(ns: Namespace, name: string, symbol: Symbol) {\n        if (!this.symbols[ns]) this.symbols[ns] = {};\n        this.symbols[ns][name] = symbol;\n    }\n\n    public hasSymbol(ns: Namespace, name: string) {\n        return !!this.symbols[ns] && typeof this.symbols[ns][name] !== 'undefined';\n    }\n\n    public getSymbol(ns: Namespace, name: string): Symbol | null {\n        return this.symbols[ns]?.[name] ?? null;\n    }\n}","import AstNode from '../parser/AstNode';\nimport TypeTable from './TypeTable';\nimport Type from '../parser/nodes/Type';\nimport { ResolvedType } from '../types/analyzer';\nimport IdentifierType from '../parser/nodes/IdentifierType';\nimport StringType from '../parser/nodes/StringType';\nimport Symbol from '../context/Symbol';\n\ntype TypeChildNode = IdentifierType | StringType;\n\nexport default class TypeResolver {\n    /**\n     * @private\n     */\n    private typeTable: TypeTable;\n\n    /**\n     * @param typeTable\n     */\n    constructor(typeTable: TypeTable) {\n        this.typeTable = typeTable;\n    }\n\n    /**\n     *\n     * @param symbol\n     * @param type\n     */\n    defineType(symbol: Symbol, type: ResolvedType) {\n        this.typeTable.registerType(symbol.getId(), type);\n    }\n\n    /**\n     * @param type\n     */\n    resolveType(type: Type): ResolvedType {\n\n        const children = type.getChildren();\n\n        if (children.length > 1) {\n            return {\n                kind: 'union',\n                members: this.normalizeUnion(children as TypeChildNode[])\n            }\n        }\n\n        if (children.length === 1) {\n            return this.resolveTypeNodeChild(children[0] as TypeChildNode);\n        }\n\n        throw new Error('TypeResolver error, no types in type?');\n    }\n\n    /**\n     * @param typeChild\n     */\n    private resolveTypeNodeChild(typeChild: TypeChildNode): ResolvedType {\n\n        if (typeChild instanceof IdentifierType) {\n\n            if (typeChild.getValue() === 'string') {\n                return {\n                    kind: 'primitive',\n                    name: 'string'\n                };\n            }\n\n            const symbol = typeChild.getSymbol();\n\n            if (!symbol) {\n                throw new Error(`Unbound type identifier '${typeChild.getValue()}'`);\n            }\n\n            return { kind: 'ref', symbolId: symbol.getId() };\n        }\n\n        if (typeChild instanceof StringType) {\n            return {\n                kind: 'literal',\n                value: typeChild.getValue()\n            };\n        }\n\n        throw new Error('Unknown type node');\n    }\n\n    /**\n     * @param nodes\n     * @private\n     */\n    private normalizeUnion(nodes: TypeChildNode[]): ResolvedType[] {\n        const resolvedTypes = [];\n\n        nodes.forEach(node => {\n            resolvedTypes.push(this.resolveTypeNodeChild(node));\n        });\n\n        return resolvedTypes;\n    }\n\n    /**\n     * @param ast\n     */\n    resolve(ast: AstNode) {\n        ast.resolve(this);\n    }\n}","import { Nullable } from '../types/nullable';\nimport { ResolvedType } from '../types/analyzer';\n\nexport default class TypeTable {\n    /**\n     * @private\n     */\n    private types: Record<number, ResolvedType> = {};\n\n    /**\n     * @param symbolId\n     * @param type\n     */\n    public registerType(symbolId: number, type: ResolvedType) {\n        this.types[symbolId] = type;\n    }\n\n    /**\n     * @param symbolId\n     */\n    public hasType(symbolId: number) {\n        return (typeof this.types[symbolId] !== 'undefined');\n    }\n\n    /**\n     * @param symbolId\n     */\n    public getType(symbolId: number): Nullable<ResolvedType> {\n        if (this.hasType(symbolId)) {\n            return this.types[symbolId];\n        }\n        return null;\n    }\n}","type DiagnosticMessage = {\n    severity: 'info' | 'warning' | 'error';\n    message: string;\n    nodeId: number;\n    // todo - add line/col later (position)\n};\n\nexport default class DiagnosticsResult {\n    /**\n     * @private\n     */\n    private messages: DiagnosticMessage[] = [];\n\n    /**\n     * @param message\n     */\n    public report(message: DiagnosticMessage) {\n        this.messages.push(message);\n    }\n\n    /**\n     *\n     */\n    public hasErrors(): boolean {\n        const errors = this.messages.filter(message => {\n            return message.severity === 'error';\n        });\n\n        return errors.length > 0;\n    }\n}","import AstNode from '../parser/AstNode';\nimport DiagnosticsResult from './DiagnosticsResult';\nimport TypeTable from './TypeTable';\nimport { ResolvedType } from '../types/analyzer';\n\nexport default class TypeChecker {\n\n    /**\n     * @private\n     */\n    private diagnostics: DiagnosticsResult;\n\n    /**\n     * @param diagnostics\n     */\n    constructor(diagnostics: DiagnosticsResult) {\n        this.diagnostics = diagnostics;\n    }\n\n    /**\n     * @param ast\n     */\n    check(ast: AstNode, typeTable: TypeTable) {\n        ast.check(this, typeTable);\n    }\n\n    /**\n     * @param type\n     * @param value\n     */\n    isAssignable(type: ResolvedType, value: string) {\n        return true;\n    }\n}","import Lexer from './tokenization/Lexer';\nimport Parser from './parser/Parser';\nimport Compiler from './compiler/Compiler';\nimport OutputBuffer from './compiler/OutputBuffer';\nimport Binder from './context/Binder';\nimport SymbolTable from './context/SymbolTable';\nimport TypeResolver from './analyzer/TypeResolver';\nimport TypeTable from './analyzer/TypeTable';\nimport DiagnosticsResult from './analyzer/DiagnosticsResult';\nimport TypeChecker from './analyzer/TypeChecker';\n\nexport default class Loom {\n    /**\n     *\n     * @param code\n     */\n    public static make(code: string): string {\n        const tokens = (new Lexer()).tokenize(code);\n\n        const ast = (new Parser().parse(tokens));\n        console.log('=== AST ===');\n        console.log(ast.print());\n\n        // Bind Symbols to AST\n        const symbolTable = new SymbolTable();\n        (new Binder(symbolTable)).bind(ast);\n\n        console.log('=== SYMBOL TABLE ===');\n        console.log(symbolTable);\n\n        // Resolve types\n        const typeTable = new TypeTable();\n        const resolver = new TypeResolver(typeTable);\n        resolver.resolve(ast);\n\n        console.log('=== TYPE TABLE ===');\n        console.log(typeTable);\n\n        // Check the types\n        const diagnostics = new DiagnosticsResult();\n        (new TypeChecker(diagnostics)).check(ast, typeTable);\n\n        console.log('=== DIAGNOSTICS ===');\n        console.log(diagnostics);\n\n        // Finally we compile\n        return (new Compiler(new OutputBuffer())).compile(ast);\n    }\n}"],"mappings":"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","names":[]}