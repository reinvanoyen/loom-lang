{"version":3,"sources":["../src/index.ts","../src/tokenization/grammar.ts","../src/tokenization/Lexer.ts","../src/parser/Node.ts","../src/parser/nodes/Identifier.ts","../src/parser/nodes/String.ts","../src/parser/nodes/Type.ts","../src/parser/nodes/VariantDeclaration.ts","../src/parser/nodes/SlotDeclaration.ts","../src/parser/nodes/Class.ts","../src/parser/nodes/TypeDeclaration.ts","../src/parser/nodes/Namespace.ts","../src/parser/AstNode.ts","../src/parser/Parser.ts","../src/compiler/OutputBuffer.ts","../src/compiler/Compiler.ts","../src/runtime/Runtime.ts","../src/Loom.ts"],"sourcesContent":["import Loom from './Loom';\n\nexport { Loom };","export default {\n    REGEX_IDENT: /\\p{L}/u,\n    REGEX_NUMBER: /\\d/,\n    REGEX_SYMBOL: /[.!?,;:()\\-+=%*\\\\/—–…${}><&#@°|]/,\n    REGEX_WHITESPACE: /\\s/,\n    REGEX_NEWLINE: /[\\n\\r]/,\n    REGEX_STRING_DELIMITER: /[\"']/,\n    STRING_ESCAPE_SYMBOL: '\\\\',\n};","import grammar from './grammar';\nimport { LexMode, TokenStream, TokenType } from '../types/tokenization';\n\nexport default class Lexer {\n    /**\n     * The source code to tokenize\n     * @private\n     */\n    private source: string;\n\n    /**\n     * The current mode of lexing\n     * @private\n     */\n    private mode: LexMode = LexMode.ALL;\n\n    /**\n     * The current position of the cursor\n     * @private\n     */\n    private cursor: number = 0;\n\n    /**\n     * The position of the cursor at the start of the mode\n     * @private\n     */\n    private modeStartCursor: number = 0;\n\n    /**\n     * The current line, starting at line 1\n     * @private\n     */\n    private line: number = 1;\n\n    /**\n     * The current position on the current line, starting at 1\n     * @private\n     */\n    private column: number = 1;\n\n    /**\n     * The current character\n     * @private\n     */\n    private character: string = '';\n\n    /**\n     * The next character, handy for simple look-ahead\n     * @private\n     */\n    private nextCharacter: string = '';\n\n    /**\n     * The index of the last character, also the amount of characters\n     * @private\n     */\n    private end: number = 0;\n\n    /**\n     * The current token stream being created\n     * @private\n     */\n    private tokens: TokenStream = [];\n\n    /**\n     * The current value being lexed\n     * @private\n     */\n    private value: string = '';\n\n    /**\n     * The current delimiter (e.g. string delimiter or boundary)\n     * @private\n     */\n    private delimiter: string = ''\n\n    /**\n     * Transforms code into a TokenStream\n     * @param text\n     */\n    tokenize(text: string): TokenStream {\n\n        this.source = text;\n        this.end = this.source.length;\n\n        while (this.cursor < this.end) {\n\n            this.character = this.source[this.cursor];\n            this.nextCharacter = this.source[this.cursor+1] || null;\n\n            // Determine the mode\n            if (this.mode === LexMode.ALL) {\n                this.mode = this.determineMode();\n                this.modeStartCursor = this.cursor;\n            }\n\n            switch (this.mode) {\n                case LexMode.STRING:\n                    this.lexString();\n                    break;\n                case LexMode.IDENT:\n                    this.lexIdent();\n                    break;\n                case LexMode.NUMBER:\n                    this.lexNumber();\n                    break;\n                case LexMode.SYMBOL:\n                    this.lexSymbol();\n                    break;\n                case LexMode.NEWLINE:\n                    this.lexNewline();\n                    break;\n                case LexMode.WHITESPACE:\n                    this.lexWhitespace();\n                    break;\n                case LexMode.UNKNOWN:\n                    this.lexUnknown();\n                    break;\n            }\n        }\n\n        return this.tokens;\n    }\n\n    /**\n     * @private\n     */\n    private atEnd(accountForDelimiter: boolean = false): boolean {\n        const offset = accountForDelimiter ? 1 : 0;\n        return this.cursor + offset >= this.end;\n    }\n\n    /**\n     * Determines the lexing mode based on the current character\n     * @private\n     */\n    private determineMode(): LexMode {\n\n        // Reset the current token value\n        this.value = '';\n\n        if (grammar.REGEX_IDENT.exec(this.character)) {\n            return LexMode.IDENT;\n        }\n\n        if (grammar.REGEX_STRING_DELIMITER.exec(this.character)) {\n            this.delimiter = this.character;\n            return LexMode.STRING;\n        }\n\n        if (grammar.REGEX_NUMBER.exec(this.character)) {\n            return LexMode.NUMBER;\n        }\n\n        if (grammar.REGEX_SYMBOL.exec(this.character)) {\n            return LexMode.SYMBOL;\n        }\n\n        if (grammar.REGEX_NEWLINE.exec(this.character)) {\n            return LexMode.NEWLINE;\n        }\n\n        if (grammar.REGEX_WHITESPACE.exec(this.character)) {\n            return LexMode.WHITESPACE;\n        }\n\n        return LexMode.UNKNOWN;\n    }\n\n    /**\n     * Tokenize string\n     * @private\n     */\n    private lexString() {\n\n        const escSequence = (this.character === grammar.STRING_ESCAPE_SYMBOL);\n\n        // String escaping\n        if (escSequence) {\n            this.cursor += 1;\n            // We directly alter the character and nextCharacter,\n            // so we can directly consume them further down in the method\n            this.character = this.source[this.cursor];\n            this.nextCharacter = this.source[this.cursor + 1] || null;\n        }\n\n        if (this.character !== this.delimiter || escSequence) {\n            // Consume the character\n            this.value += this.character;\n        }\n\n        this.cursor++;\n\n        if (this.nextCharacter === this.delimiter) {\n            this.tokens.push({\n                type: TokenType.STRING,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(true),\n            });\n            this.cursor++;\n            this.column += this.cursor - this.modeStartCursor;\n            this.mode = LexMode.ALL;\n            this.delimiter = '';\n        }\n    }\n    \n    /**\n     * Tokenize identifier\n     * @private\n     */\n    private lexIdent() {\n\n        this.value += this.character;\n        this.cursor++;\n\n        if (! this.nextCharacter || ! grammar.REGEX_IDENT.exec(this.nextCharacter)) {\n            this.tokens.push({\n                type: TokenType.IDENT,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.column += this.value.length;\n            this.mode = LexMode.ALL;\n        }\n    }\n\n    /**\n     * Tokenize number\n     * @private\n     */\n    private lexNumber() {\n        this.value += this.character;\n        this.cursor++;\n\n        if (!this.nextCharacter || !grammar.REGEX_NUMBER.exec(this.nextCharacter)) {\n            this.tokens.push({\n                type: TokenType.NUMBER,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.column += this.cursor - this.modeStartCursor;\n            this.mode = LexMode.ALL;\n        }\n    }\n\n    /**\n     * Tokenize symbol\n     * @private\n     */\n    private lexSymbol() {\n\n        this.cursor++;\n\n        this.tokens.push({\n            type: TokenType.SYMBOL,\n            value: this.character,\n            line: this.line,\n            position: this.column,\n            end: this.atEnd(),\n        });\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n\n    /**\n     * Tokenize newline\n     * @private\n     */\n    private lexNewline() {\n        this.cursor++;\n        this.line++;\n        this.column = 1;\n        this.mode = LexMode.ALL;\n    }\n\n    /**\n     * Tokenize whitespace\n     * @private\n     */\n    private lexWhitespace() {\n        this.cursor++;\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n\n    /**\n     * Tokenize unknown\n     * @private\n     */\n    private lexUnknown() {\n        this.tokens.push({\n            type: TokenType.UNKNOWN,\n            value: this.character,\n            line: this.line,\n            position: this.column,\n            end: this.atEnd(),\n        });\n        this.cursor++;\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n}","import { Nullable } from '../types/nullable';\nimport { AttributeValue } from '../types/attribute';\nimport Parser from './Parser';\nimport Compiler from '../compiler/Compiler';\n\nexport default class Node {\n\n    /**\n     *\n     * @protected\n     */\n    protected value: string;\n\n    /**\n     *\n     * @protected\n     */\n    protected parent: Nullable<Node> = null;\n\n    /**\n     *\n     * @protected\n     */\n    protected children: Node[] = [];\n\n    /**\n     *\n     * @protected\n     */\n    protected attributes: Record<string, AttributeValue> = {};\n\n    /**\n     *\n     * @param value\n     */\n    constructor(value: string = '') {\n        this.value = value;\n    }\n\n    /**\n     *\n     */\n    getName(): string {\n        return this.constructor.name;\n    }\n\n    /**\n     *\n     * @param node\n     */\n    setParent(node: Node) {\n        this.parent = node;\n    }\n\n    /**\n     *\n     */\n    getParent(): Node {\n        return this.parent;\n    }\n\n    /**\n     *\n     */\n    getValue(): string {\n        return this.value;\n    }\n\n    /**\n     *\n     * @param value\n     */\n    setValue(value: string) {\n        this.value = value;\n    }\n\n    /**\n     *\n     * @param node\n     */\n    addChild(node: Node) {\n        this.children.push(node);\n    }\n\n    /**\n     *\n     */\n    getChildren() {\n        return this.children;\n    }\n\n    /**\n     *\n     */\n    hasChildren() {\n        return (this.children.length > 0);\n    }\n\n    /**\n     *\n     * @param name\n     * @param value\n     */\n    setAttribute(name: string, value: AttributeValue) {\n        this.attributes[name] = value;\n    }\n\n    /**\n     *\n     * @param name\n     */\n    getAttribute(name: string): Nullable<AttributeValue> {\n        return this.attributes[name] || null;\n    }\n\n    /**\n     *\n     */\n    getAttributes(): Record<string, AttributeValue> {\n        return this.attributes;\n    }\n\n    /**\n     *\n     */\n    removeLastChild() {\n        this.children.pop();\n    }\n\n    /**\n     *\n     * @param _parser\n     */\n    parse(_parser: Parser): boolean {\n        return false;\n    }\n\n    /**\n     *\n     * @param _compiler\n     */\n    compile(compiler: Compiler) {\n        // todo\n    }\n\n    print(): string {\n\n        const printNode = (node: Node, indentAmount: number = 0): string => {\n\n            const nodeName = node.getName();\n            const nodeValue = node.getValue();\n\n            const attributes = node.getAttributes();\n            const attributesString = [];\n            for (const attribute in attributes) {\n                let attrValue = attributes[attribute];\n                if (attrValue instanceof Node) {\n                    const attrNodeValue = attrValue.getValue();\n                    attrValue = `${attrValue.getName()}${attrNodeValue ? `(${attrNodeValue})` : ''}`;\n                }\n                attributesString.push(`${attribute}=${attrValue}`);\n            }\n\n            const tabs = indentAmount > 0 ? '   '.repeat(indentAmount - 1) + '└──' : '';\n            const output = [`${tabs}${nodeName}${nodeValue ? `(${nodeValue})` : ''} ${attributesString.join(' ')}`];\n\n            node.getChildren().forEach(childNode => {\n                output.push(printNode(childNode, indentAmount + 1));\n            });\n\n            return output.join('\\n');\n        };\n\n        return printNode(this);\n    }\n}","import Node from '../Node';\n\nexport default class Identifier extends Node {\n\n    compile() {\n        // todo compile TypeIdentNode\n    }\n}","import Node from '../Node';\n\nexport default class String extends Node {\n\n    compile() {\n        // todo compile TypeIdentNode\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport Identifier from './Identifier';\nimport String from './String';\n\nexport default class Type extends Node {\n    /**\n     * @param parser\n     */\n    static parse(parser: Parser): boolean {\n\n        parser.expectOneOf([TokenType.IDENT, TokenType.STRING]);\n\n        parser.insert(new Type());\n        parser.in();\n\n        if (this.parseUnionType(parser)) {\n            parser.out();\n            return true;\n        }\n\n        return false;\n    }\n\n    private static parseType(parser: Parser) {\n        if (parser.accept(TokenType.IDENT)) {\n            parser.insert(new Identifier(parser.getCurrentValue()))\n            parser.advance();\n            return true;\n        }\n\n        if (parser.accept(TokenType.STRING)) {\n            parser.insert(new String(parser.getCurrentValue()))\n            parser.advance();\n            return true;\n        }\n\n        return false;\n    }\n\n    private static parseUnionType(parser: Parser) {\n        if (this.parseType(parser)) {\n            if (parser.skipWithValue(TokenType.SYMBOL, '|')) {\n                this.parseUnionType(parser);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    compile() {\n        // todo compile VariantDefinition\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport Type from './Type';\n\nexport default class VariantDeclaration extends Node {\n    /**\n     * @param parser\n     */\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.SYMBOL,'@')) {\n            parser.expect(TokenType.IDENT);\n            parser.insert(new VariantDeclaration());\n            parser.in();\n            parser.setAttribute('name', parser.getCurrentValue());\n            parser.advance();\n\n            parser.expectWithValue(TokenType.SYMBOL, ':');\n            parser.advance();\n\n            Type.parse(parser);\n            parser.setAttribute('type');\n\n            // Parse default value\n            if (parser.skipWithValue(TokenType.SYMBOL, '=')) {\n                parser.expect(TokenType.STRING);\n                parser.setAttribute('default', parser.getCurrentValue());\n                parser.advance();\n            }\n\n            parser.out();\n            parser.expectWithValue(TokenType.SYMBOL, ';');\n            parser.advance();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile() {\n        // todo compile VariantDefinition\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport Compiler from '../../compiler/Compiler';\n\nexport default class SlotDeclaration extends Node {\n    /**\n     * @param parser\n     */\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.IDENT,'slot')) {\n            parser.expect(TokenType.IDENT);\n            parser.insert(new SlotDeclaration(parser.getCurrentValue()));\n            parser.advance();\n\n            parser.expectWithValue(TokenType.SYMBOL, ';');\n            parser.advance();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        compiler.writeLine(`.${this.getValue()} {}`);\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport VariantDeclaration from './VariantDeclaration';\nimport SlotDeclaration from './SlotDeclaration';\nimport Compiler from '../../compiler/Compiler';\n\nexport default class Class extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.IDENT, 'class')) {\n\n            if (parser.expect(TokenType.IDENT)) {\n                parser.insert(new Class(parser.getCurrentValue()));\n                parser.traverseUp();\n                parser.advance();\n            }\n\n            if (parser.skipWithValue(TokenType.IDENT, 'extends')) {\n                parser.expect(TokenType.IDENT);\n                parser.setAttribute('extends', parser.getCurrentValue());\n                parser.advance();\n            }\n\n            parser.expectWithValue(TokenType.SYMBOL, '{');\n            parser.advance();\n\n            // Parse class body\n            while(\n                VariantDeclaration.parse(parser) ||\n                SlotDeclaration.parse(parser)\n            );\n\n            if (parser.expectWithValue(TokenType.SYMBOL, '}')) {\n                parser.out();\n                parser.advance();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n\n        // Register the class on runtime\n        compiler.getRuntime().registerClass(this.getValue());\n\n        // Get current namespace\n        const namespace = compiler.getRuntime().getNamespace();\n\n        // Build classname\n        const className = `${namespace ? namespace+'-' : '' }${this.getValue()}`;\n\n        // Write CSS :)\n        compiler.writeLine(`.${className} {`);\n\n        this.getChildren().forEach(child => {\n            child.compile(compiler);\n        });\n\n        compiler.writeLine('}');\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport Type from './Type';\n\nexport default class TypeDeclaration extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.IDENT, 'type')) {\n            parser.insert(new TypeDeclaration());\n            parser.in();\n\n            if (parser.expect(TokenType.IDENT)) {\n                parser.setAttribute('name', parser.getCurrentValue());\n                parser.advance();\n            }\n\n            parser.expectWithValue(TokenType.SYMBOL, ':');\n            parser.advance();\n\n            Type.parse(parser);\n\n            parser.out();\n            parser.expectWithValue(TokenType.SYMBOL, ';');\n            parser.advance();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile() {\n        // todo compile ClassNode\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport Compiler from '../../compiler/Compiler';\n\nexport default class Namespace extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.IDENT, 'namespace')) {\n            parser.expect(TokenType.IDENT);\n            parser.insert(new Namespace(parser.getCurrentValue()));\n            parser.advance();\n\n            parser.expectWithValue(TokenType.SYMBOL, ';');\n            parser.advance();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        // Set the current namespace\n        compiler.getRuntime().setNamespace(this.getValue());\n    }\n}","import Node from './Node';\nimport Parser from './Parser';\nimport Class from './nodes/Class';\nimport TypeDeclaration from './nodes/TypeDeclaration';\nimport Namespace from './nodes/Namespace';\nimport Compiler from '../compiler/Compiler';\n\nexport default class AstNode extends Node {\n\n    static parse(parser: Parser): boolean {\n        \n        while(\n            Namespace.parse(parser) ||\n            TypeDeclaration.parse(parser) ||\n            Class.parse(parser)\n        );\n\n        return true;\n    }\n\n    compile(compiler: Compiler) {\n        this.getChildren().forEach(child => {\n            child.compile(compiler);\n        });\n    }\n}","import { Token, TokenStream, TokenType } from '../types/tokenization';\nimport AstNode from './AstNode';\nimport Node from './Node';\nimport { Nullable } from '../types/nullable';\n\nexport default class Parser {\n\n    /**\n     * The current position of the cursor\n     * @private\n     */\n    private cursor: number = 0;\n\n    /**\n     * The TokenStream currently being parsed (input)\n     * @private\n     */\n    private tokens: TokenStream;\n\n    /**\n     * The Abstract Syntax Tree (AST) currently being build (output)\n     * @private\n     */\n    private ast: AstNode = new AstNode();\n\n    /**\n     * The current scope, which is the Node in which we're currently parser\n     * @private\n     */\n    private scope: Node = this.ast;\n\n    /**\n     * Parse a TokenStream into an Abstract Syntax Tree (AST)\n     * @param tokens\n     */\n    public parse(tokens: TokenStream): AstNode {\n\n        this.setTokenStream(tokens);\n        this.parseAll();\n\n        return this.ast;\n    }\n\n    /**\n     * Set the TokenStream\n     * @param tokens\n     */\n    public setTokenStream(tokens: TokenStream) {\n        this.tokens = tokens;\n    }\n\n    /**\n     * Parse all tokens in the TokenStream, starting from the cursor position\n     */\n    private parseAll() {\n\n        if (! this.tokens.length) {\n            return;\n        }\n\n        if (this.cursor > (this.tokens.length-1)) {\n            return;\n        }\n\n        if (AstNode.parse(this)) {\n            this.parseAll();\n        }\n    }\n\n    /**\n     * Get the Token at the cursor position\n     */\n    public getCurrentToken(): Token {\n        return this.tokens[this.cursor];\n    }\n\n    /**\n     * Get the Token at the offset of the cursor position\n     * @param offset\n     */\n    private getOffsetToken(offset: number): Token {\n        return this.tokens[this.cursor + offset];\n    }\n\n    /**\n     * Set a value as attribute to the current scope Node\n     * If no explicit value was given, the last inserted Node will be used as value\n     * @param name\n     * @param value\n     */\n    public setAttribute(name: string, value: Nullable<string | Node> = null) {\n        if (value === null) {\n            value = this.getLastNode();\n            this.getScope().removeLastChild();\n        }\n        this.getScope().setAttribute(name, value);\n    }\n\n    /**\n     * Get the value of the current token\n     */\n    public getCurrentValue(): string {\n        return this.getCurrentToken().value;\n    }\n\n    /**\n     * Advance the cursor position by a certain offset\n     * @param offset\n     */\n    public advance(offset: number = 1) {\n        this.cursor = this.cursor + offset;\n    }\n\n    /**\n     * Accept a token of the given type at this cursor position\n     * @param type\n     */\n    public accept(type: TokenType): boolean {\n        const token = this.getCurrentToken();\n        return (token && token.type === type);\n    }\n\n    /**\n     * Accept a token of the given type and with given value at this cursor position\n     * @param type\n     * @param value\n     */\n    public acceptWithValue(type: TokenType, value: string): boolean {\n        const token = this.getCurrentToken();\n        return (\n            token &&\n            token.type === type &&\n            token.value === value\n        );\n    }\n\n    /**\n     * Accept a token of the given type at the given offset of this cursor position\n     * @param type\n     * @param offset\n     */\n    public acceptAt(type: TokenType, offset: number): boolean {\n        const token = this.getOffsetToken(offset);\n        return (token && token.type === type);\n    }\n\n    /**\n     * Accept a token of the given type and with given value at the given offset of this cursor position\n     * @param type\n     * @param offset\n     * @param value\n     */\n    public acceptAtWithValue(type: TokenType, offset: number, value: string): boolean {\n        const token = this.getOffsetToken(offset);\n        return (\n            token &&\n            token.type === type &&\n            token.value === value\n        );\n    }\n\n    /**\n     * @param types\n     */\n    public acceptOneOf(types: TokenType[]): boolean {\n        const token = this.getCurrentToken();\n        return (token && types.includes(token.type));\n    }\n\n    /**\n     * Skip a token of the given type at this cursor position\n     * @param type\n     */\n    public skip(type: TokenType): boolean {\n        if (this.accept(type)) {\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Skip the token at this cursor position if it's of the given type and has the given value\n     * @param type\n     * @param value\n     */\n    public skipWithValue(type: TokenType, value: string): boolean {\n        if (this.acceptWithValue(type, value)) {\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Expect a token of the given type at this cursor position\n     * @param type\n     */\n    public expect(type: TokenType): boolean {\n        if (this.accept(type)) {\n            return true;\n        }\n        throw new Error('Unexpected token');\n        // todo implement UnexpectedToken error\n        //throw new UnexpectedToken(type, this.getCurrentToken());\n    }\n\n    /**\n     * Expect a token of the given type with give value at this cursor position\n     * @param type\n     * @param value\n     */\n    public expectWithValue(type: TokenType, value: string): boolean {\n        if (this.acceptWithValue(type, value)) {\n            return true;\n        }\n        throw new Error(`Unexpected token, expected ${type} with value ${value} got ${this.getCurrentToken().type} ${this.getCurrentToken().value}`);\n        // todo implement UnexpectedToken error\n        //throw new UnexpectedToken(type, this.getCurrentToken());\n    }\n\n    /**\n     * Expect a token of the given type and with given value at the given offset of this cursor position\n     * @param type\n     * @param offset\n     * @param value\n     */\n    public expectAtWithValue(type: TokenType, offset: number, value: string): boolean {\n        if (this.acceptAtWithValue(type, offset, value)) {\n            return true;\n        }\n        throw new Error('Unexpected token');\n        // todo implement UnexpectedToken error\n        //throw new UnexpectedToken(type, this.getCurrentToken());\n    }\n\n    /**\n     *\n     * @param types\n     */\n    public expectOneOf(types: TokenType[]): boolean {\n        if (this.acceptOneOf(types)) {\n            return true;\n        }\n        throw new Error('Unexpected token, expected one of: '+types.join(', '));\n        // todo implement UnexpectedToken error\n        //throw new UnexpectedToken(type, this.getCurrentToken());\n    }\n\n    /**\n     * Point the scope to the last inserted Node\n     */\n    public in() {\n        this.setScope(this.getLastNode());\n    }\n\n    /**\n     * Point the scope to the parent of the current scope\n     */\n    public out() {\n        this.setScope(this.getScope().getParent());\n    }\n\n    /**\n     * Alias of in()\n     */\n    public traverseUp() {\n        this.in();\n    }\n\n    /**\n     * Alias of out()\n     */\n    public traverseDown() {\n        this.out();\n    }\n\n    /**\n     * Get the current scope Node\n     */\n    public getScope(): Node {\n        return this.scope;\n    }\n\n    /**\n     * Get the last inserted Node\n     */\n    public getLastNode(): Node {\n        return this.scope.getChildren()[this.scope.getChildren().length-1];\n    }\n\n    /**\n     * Insert a Node into the current scope\n     * @param node\n     */\n    public insert(node: Node) {\n        node.setParent(this.scope);\n        this.scope.addChild(node);\n    }\n\n    /**\n     * Set the current scope\n     * @param node\n     */\n    private setScope(node: Node) {\n        this.scope = node;\n    }\n\n    /**\n     * Wrap the last inserted Node with another Node, the scope will be the wrapping Node\n     * @param node\n     */\n    public wrap(node: Node) {\n        const last = this.getLastNode();\n        this.getScope().removeLastChild();\n\n        this.insert(node);\n        this.traverseUp();\n\n        this.insert(last);\n    }\n\n    /**\n     * Get the built Abstract Syntax Tree (AST)\n     */\n    public getAst(): AstNode {\n        return this.ast;\n    }\n}","export default class OutputBuffer {\n\n    /**\n     *\n     * @private\n     */\n    private head: string[] = [];\n\n    /**\n     *\n     * @private\n     */\n    private body: string[] = [];\n\n    /**\n     *\n     * @private\n     */\n    private foot: string[] = [];\n\n    /**\n     *\n     * @param string\n     */\n    writeBody(string: string) {\n        this.body.push(string);\n    }\n\n    /**\n     *\n     * @param string\n     */\n    writeHead(string: string) {\n        this.head.push(string);\n    }\n\n    /**\n     *\n     * @param string\n     */\n    writeFoot(string: string) {\n        this.foot.push(string);\n    }\n\n    /**\n     *\n     */\n    getHead(): string {\n        return this.head.join('');\n    }\n\n    /**\n     *\n     */\n    getBody(): string {\n        return this.body.join('');\n    }\n\n    /**\n     *\n     */\n    getFoot(): string {\n        return this.foot.join('');\n    }\n\n    render(): string {\n        return this.getHead()+this.getBody()+this.getFoot();\n    }\n}","import Node from '../parser/Node';\nimport OutputBuffer from './OutputBuffer';\nimport Runtime from '../runtime/Runtime';\n\nexport default class Compiler {\n    /**\n     * @private\n     */\n    private readonly runtime: Runtime;\n\n    /**\n     * @private\n     */\n    private readonly buffer: OutputBuffer;\n\n    /**\n     *\n     */\n    constructor(runtime: Runtime) {\n        this.runtime = runtime;\n        this.buffer = new OutputBuffer();\n    }\n\n    public getRuntime(): Runtime {\n        return this.runtime;\n    }\n\n    /**\n     *\n     * @param string\n     */\n    write(string: string) {\n        this.buffer.writeBody(string);\n    }\n\n    writeLine(string: string) {\n        this.buffer.writeBody('\\n'+string);\n    }\n\n    compile(ast: Node) {\n        ast.compile(this);\n        return this.buffer.render();\n    }\n}","export default class Runtime {\n\n    /**\n     * @private\n     */\n    private namespaces: string[] = [];\n\n    /**\n     * @private\n     */\n    private currentNamespace: string | null = null;\n\n    /**\n     * @private\n     */\n    private classes: Record<string, string[]> = {};\n\n    /**\n     * @param name\n     */\n    public setNamespace(name: string) {\n        if (! this.namespaces.includes(name)) {\n            this.namespaces.push(name);\n        }\n\n        this.currentNamespace = name;\n    }\n\n    /**\n     *\n     */\n    public getNamespace(): string | null {\n        return this.currentNamespace;\n    }\n\n    /**\n     *\n     * @param name\n     */\n    public registerClass(name: string) {\n        if (! this.classes[this.currentNamespace]) {\n            this.classes[this.currentNamespace] = [];\n        }\n\n        this.classes[this.currentNamespace].push(name);\n    }\n}","import Lexer from './tokenization/Lexer';\nimport Parser from './parser/Parser';\nimport Compiler from './compiler/Compiler';\nimport Runtime from './runtime/Runtime';\n\nexport default class Loom {\n    /**\n     *\n     * @param code\n     */\n    public static make(code: string): string {\n        const tokens = (new Lexer()).tokenize(code);\n\n        const ast = (new Parser().parse(tokens));\n        console.log(ast.print());\n        \n        return (new Compiler(new Runtime())).compile(ast);\n    }\n}"],"mappings":"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","names":[]}