{"version":3,"sources":["../src/index.ts","../src/tokenization/grammar.ts","../src/tokenization/Lexer.ts","../src/parsing/Node.ts","../src/nodes/VariantDefinition.ts","../src/nodes/ClassNode.ts","../src/parsing/AstNode.ts","../src/parsing/Parser.ts","../src/Loom.ts"],"sourcesContent":["import Loom from './Loom';\n\nexport { Loom };","export default {\n    REGEX_IDENT: /\\p{L}/u,\n    REGEX_NUMBER: /\\d/,\n    REGEX_SYMBOL: /[.!?,;:()\\-+=%*\\\\/—–…${}><&#@°|]/,\n    REGEX_WHITESPACE: /\\s/,\n    REGEX_NEWLINE: /[\\n\\r]/,\n    REGEX_STRING_DELIMITER: /[\"']/,\n};","import grammar from './grammar';\nimport { LexMode, TokenStream, TokenType } from '../types/tokenization';\n\nexport default class Lexer {\n    /**\n     * The source code to tokenize\n     * @private\n     */\n    private source: string;\n\n    /**\n     * The current mode of lexing\n     * @private\n     */\n    private mode: LexMode = LexMode.ALL;\n\n    /**\n     * The current position of the cursor\n     * @private\n     */\n    private cursor: number = 0;\n\n    /**\n     * The position of the cursor at the start of the mode\n     * @private\n     */\n    private modeStartCursor: number = 0;\n\n    /**\n     * The current line, starting at line 1\n     * @private\n     */\n    private line: number = 1;\n\n    /**\n     * The current position on the current line, starting at 1\n     * @private\n     */\n    private column: number = 1;\n\n    /**\n     * The current character\n     * @private\n     */\n    private character: string = '';\n\n    /**\n     * The next character, handy for simple look-ahead\n     * @private\n     */\n    private nextCharacter: string = '';\n\n    /**\n     * The index of the last character, also the amount of characters\n     * @private\n     */\n    private end: number = 0;\n\n    /**\n     * The current token stream being created\n     * @private\n     */\n    private tokens: TokenStream = [];\n\n    /**\n     * The current value being lexed\n     * @private\n     */\n    private value: string = '';\n\n    /**\n     * The current delimiter (e.g. string delimiter or boundary)\n     * @private\n     */\n    private delimiter: string = ''\n\n    /**\n     * Transforms code into a TokenStream\n     * @param text\n     */\n    tokenize(text: string): TokenStream {\n\n        this.source = text;\n        this.end = this.source.length;\n\n        while (this.cursor < this.end) {\n\n            this.character = this.source[this.cursor];\n            this.nextCharacter = this.source[this.cursor+1] || null;\n\n            // Determine the mode\n            if (this.mode === LexMode.ALL) {\n                this.mode = this.determineMode();\n                this.modeStartCursor = this.cursor;\n            }\n\n            switch (this.mode) {\n                case LexMode.IDENT:\n                    this.lexIdent();\n                    break;\n                case LexMode.NUMBER:\n                    this.lexNumber();\n                    break;\n                case LexMode.SYMBOL:\n                    this.lexSymbol();\n                    break;\n                case LexMode.NEWLINE:\n                    this.lexNewline();\n                    break;\n                case LexMode.WHITESPACE:\n                    this.lexWhitespace();\n                    break;\n                case LexMode.UNKNOWN:\n                    this.lexUnknown();\n                    break;\n            }\n        }\n\n        return this.tokens;\n    }\n\n    /**\n     * @private\n     */\n    private atEnd(accountForDelimiter: boolean = false): boolean {\n        const offset = accountForDelimiter ? 1 : 0;\n        return this.cursor + offset >= this.end;\n    }\n\n    /**\n     * Determines the lexing mode based on the current character\n     * @private\n     */\n    private determineMode(): LexMode {\n\n        // Reset the current token value\n        this.value = '';\n\n        if (grammar.REGEX_IDENT.exec(this.character)) {\n            return LexMode.IDENT;\n        }\n\n        if (grammar.REGEX_STRING_DELIMITER.exec(this.character)) {\n            this.delimiter = this.character;\n            return LexMode.STRING;\n        }\n\n        if (grammar.REGEX_NUMBER.exec(this.character)) {\n            return LexMode.NUMBER;\n        }\n\n        if (grammar.REGEX_SYMBOL.exec(this.character)) {\n            return LexMode.SYMBOL;\n        }\n\n        if (grammar.REGEX_NEWLINE.exec(this.character)) {\n            return LexMode.NEWLINE;\n        }\n\n        if (grammar.REGEX_WHITESPACE.exec(this.character)) {\n            return LexMode.WHITESPACE;\n        }\n\n        return LexMode.UNKNOWN;\n    }\n\n    /**\n     * Tokenize identifier\n     * @private\n     */\n    private lexIdent() {\n\n        this.value += this.character;\n        this.cursor++;\n\n        if (! this.nextCharacter || ! grammar.REGEX_IDENT.exec(this.nextCharacter)) {\n            this.tokens.push({\n                type: TokenType.IDENT,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.column += this.value.length;\n            this.mode = LexMode.ALL;\n        }\n    }\n\n    /**\n     * Tokenize number\n     * @private\n     */\n    private lexNumber() {\n        this.value += this.character;\n        this.cursor++;\n\n        if (!this.nextCharacter || !grammar.REGEX_NUMBER.exec(this.nextCharacter)) {\n            this.tokens.push({\n                type: TokenType.NUMBER,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.column += this.cursor - this.modeStartCursor;\n            this.mode = LexMode.ALL;\n        }\n    }\n\n    /**\n     * Tokenize symbol\n     * @private\n     */\n    private lexSymbol() {\n\n        this.cursor++;\n\n        this.tokens.push({\n            type: TokenType.SYMBOL,\n            value: this.character,\n            line: this.line,\n            position: this.column,\n            end: this.atEnd(),\n        });\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n\n    /**\n     * Tokenize newline\n     * @private\n     */\n    private lexNewline() {\n        this.cursor++;\n        this.line++;\n        this.column = 1;\n        this.mode = LexMode.ALL;\n    }\n\n    /**\n     * Tokenize whitespace\n     * @private\n     */\n    private lexWhitespace() {\n        this.cursor++;\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n\n    /**\n     * Tokenize unknown\n     * @private\n     */\n    private lexUnknown() {\n        this.tokens.push({\n            type: TokenType.UNKNOWN,\n            value: this.character,\n            line: this.line,\n            position: this.column,\n            end: this.atEnd(),\n        });\n        this.cursor++;\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n}","import { Nullable } from '../types/nullable';\nimport { AttributeValue } from '../types/attribute';\nimport Parser from './Parser';\n\nexport default class Node {\n\n    /**\n     *\n     * @protected\n     */\n    protected value: string;\n\n    /**\n     *\n     * @protected\n     */\n    protected parent: Nullable<Node> = null;\n\n    /**\n     *\n     * @protected\n     */\n    protected children: Node[] = [];\n\n    /**\n     *\n     * @protected\n     */\n    protected attributes: Record<string, AttributeValue> = {};\n\n    /**\n     *\n     * @param value\n     */\n    constructor(value: string = '') {\n        this.value = value;\n    }\n\n    /**\n     *\n     */\n    getName(): string {\n        return this.constructor.name;\n    }\n\n    /**\n     *\n     * @param node\n     */\n    setParent(node: Node) {\n        this.parent = node;\n    }\n\n    /**\n     *\n     */\n    getParent(): Node {\n        return this.parent;\n    }\n\n    /**\n     *\n     */\n    getValue(): string {\n        return this.value;\n    }\n\n    /**\n     *\n     * @param value\n     */\n    setValue(value: string) {\n        this.value = value;\n    }\n\n    /**\n     *\n     * @param node\n     */\n    addChild(node: Node) {\n        this.children.push(node);\n    }\n\n    /**\n     *\n     */\n    getChildren() {\n        return this.children;\n    }\n\n    /**\n     *\n     */\n    hasChildren() {\n        return (this.children.length > 0);\n    }\n\n    /**\n     *\n     * @param name\n     * @param value\n     */\n    setAttribute(name: string, value: AttributeValue) {\n        this.attributes[name] = value;\n    }\n\n    /**\n     *\n     * @param name\n     */\n    getAttribute(name: string): Nullable<AttributeValue> {\n        return this.attributes[name] || null;\n    }\n\n    /**\n     *\n     */\n    getAttributes(): Record<string, AttributeValue> {\n        return this.attributes;\n    }\n\n    /**\n     *\n     */\n    removeLastChild() {\n        this.children.pop();\n    }\n\n    /**\n     *\n     * @param _parser\n     */\n    parse(_parser: Parser): boolean {\n        return false;\n    }\n\n    /**\n     *\n     * @param _compiler\n     */\n    compile() {\n        // todo\n    }\n\n    print(): string {\n\n        const printNode = (node: Node, indentAmount: number = 0): string => {\n\n            const nodeName = node.getName();\n            const nodeValue = node.getValue();\n\n            const attributes = node.getAttributes();\n            const attributesString = [];\n            for (const attribute in attributes) {\n                let attrValue = attributes[attribute];\n                if (attrValue instanceof Node) {\n                    const attrNodeValue = attrValue.getValue();\n                    attrValue = `${attrValue.getName()}${attrNodeValue ? `(${attrNodeValue})` : ''}`;\n                }\n                attributesString.push(`${attribute}=${attrValue}`);\n            }\n\n            const tabs = indentAmount > 0 ? '   '.repeat(indentAmount - 1) + '└──' : '';\n            const output = [`${tabs}${nodeName}${nodeValue ? `(${nodeValue})` : ''} ${attributesString.join(' ')}`];\n\n            node.getChildren().forEach(childNode => {\n                output.push(printNode(childNode, indentAmount + 1));\n            });\n\n            return output.join('\\n');\n        };\n\n        return printNode(this);\n    }\n}","import Node from '../parsing/Node';\nimport Parser from '../parsing/Parser';\nimport { TokenType } from '../types/tokenization';\n\nexport default class VariantDefinition extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.acceptWithValue(TokenType.SYMBOL,'@')) {\n            parser.advance(9);\n            return true;\n        }\n        return false;\n    }\n\n    compile() {\n        // todo compile VariantDefinition\n    }\n}","import Node from '../parsing/Node';\nimport Parser from '../parsing/Parser';\nimport { TokenType } from '../types/tokenization';\nimport VariantDefinition from './VariantDefinition';\n\nexport default class ClassNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.IDENT, 'class')) {\n            parser.insert(new ClassNode());\n            parser.traverseUp();\n\n            if (parser.expect(TokenType.IDENT)) {\n                parser.setAttribute('name', parser.getCurrentValue());\n                parser.advance();\n            }\n            \n            parser.expectWithValue(TokenType.SYMBOL, '{');\n            parser.advance();\n\n            // Parse class body\n            while(\n                VariantDefinition.parse(parser)\n            );\n\n            if (parser.expectWithValue(TokenType.SYMBOL, '}')) {\n                parser.out();\n                parser.advance();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile() {\n        // todo compile ClassNode\n    }\n}","import Node from './Node';\nimport Parser from './Parser';\nimport ClassNode from '../nodes/ClassNode';\n\nexport default class AstNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        while(\n            ClassNode.parse(parser)\n        );\n\n        return true;\n    }\n\n    compile() {\n        // todo compile\n    }\n}","import { Token, TokenStream, TokenType } from '../types/tokenization';\nimport AstNode from './AstNode';\nimport Node from './Node';\nimport { Nullable } from '../types/nullable';\n\nexport default class Parser {\n\n    /**\n     * The current position of the cursor\n     * @private\n     */\n    private cursor: number = 0;\n\n    /**\n     * The TokenStream currently being parsed (input)\n     * @private\n     */\n    private tokens: TokenStream;\n\n    /**\n     * The Abstract Syntax Tree (AST) currently being build (output)\n     * @private\n     */\n    private ast: AstNode = new AstNode();\n\n    /**\n     * The current scope, which is the Node in which we're currently parsing\n     * @private\n     */\n    private scope: Node = this.ast;\n\n    /**\n     * Parse a TokenStream into an Abstract Syntax Tree (AST)\n     * @param tokens\n     */\n    public parse(tokens: TokenStream): AstNode {\n\n        this.setTokenStream(tokens);\n        this.parseAll();\n\n        return this.ast;\n    }\n\n    /**\n     * Set the TokenStream\n     * @param tokens\n     */\n    public setTokenStream(tokens: TokenStream) {\n        this.tokens = tokens;\n    }\n\n    /**\n     * Parse all tokens in the TokenStream, starting from the cursor position\n     */\n    private parseAll() {\n\n        if (! this.tokens.length) {\n            return;\n        }\n\n        if (this.cursor > (this.tokens.length-1)) {\n            return;\n        }\n\n        if (AstNode.parse(this)) {\n            this.parseAll();\n        }\n    }\n\n    /**\n     * Get the Token at the cursor position\n     */\n    public getCurrentToken(): Token {\n        return this.tokens[this.cursor];\n    }\n\n    /**\n     * Get the Token at the offset of the cursor position\n     * @param offset\n     */\n    private getOffsetToken(offset: number): Token {\n        return this.tokens[this.cursor + offset];\n    }\n\n    /**\n     * Set a value as attribute to the current scope Node\n     * If no explicit value was given, the last inserted Node will be used as value\n     * @param name\n     * @param value\n     */\n    public setAttribute(name: string, value: Nullable<string | Node> = null) {\n        if (value === null) {\n            value = this.getLastNode();\n            this.getScope().removeLastChild();\n        }\n        this.getScope().setAttribute(name, value);\n    }\n\n    /**\n     * Get the value of the current token\n     */\n    public getCurrentValue(): string {\n        return this.getCurrentToken().value;\n    }\n\n    /**\n     * Advance the cursor position by a certain offset\n     * @param offset\n     */\n    public advance(offset: number = 1) {\n        this.cursor = this.cursor + offset;\n    }\n\n    /**\n     * Accept a token of the given type at this cursor position\n     * @param type\n     */\n    public accept(type: TokenType): boolean {\n        const token = this.getCurrentToken();\n        return (token && token.type === type);\n    }\n\n    /**\n     * Accept a token of the given type and with given value at this cursor position\n     * @param type\n     * @param value\n     */\n    public acceptWithValue(type: TokenType, value: string): boolean {\n        const token = this.getCurrentToken();\n        return (\n            token &&\n            token.type === type &&\n            token.value === value\n        );\n    }\n\n    /**\n     * Accept a token of the given type at the given offset of this cursor position\n     * @param type\n     * @param offset\n     */\n    public acceptAt(type: TokenType, offset: number): boolean {\n        const token = this.getOffsetToken(offset);\n        return (token && token.type === type);\n    }\n\n    /**\n     * Accept a token of the given type and with given value at the given offset of this cursor position\n     * @param type\n     * @param offset\n     * @param value\n     */\n    public acceptAtWithValue(type: TokenType, offset: number, value: string): boolean {\n        const token = this.getOffsetToken(offset);\n        return (\n            token &&\n            token.type === type &&\n            token.value === value\n        );\n    }\n\n    /**\n     * Skip a token of the given type at this cursor position\n     * @param type\n     */\n    public skip(type: TokenType): boolean {\n        if (this.accept(type)) {\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Skip the token at this cursor position if it's of the given type and has the given value\n     * @param type\n     * @param value\n     */\n    public skipWithValue(type: TokenType, value: string): boolean {\n        if (this.acceptWithValue(type, value)) {\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Expect a token of the given type at this cursor position\n     * @param type\n     */\n    public expect(type: TokenType): boolean {\n        if (this.accept(type)) {\n            return true;\n        }\n        throw new Error('Unexpected token');\n        // todo implement UnexpectedToken error\n        //throw new UnexpectedToken(type, this.getCurrentToken());\n    }\n\n    /**\n     * Expect a token of the given type with give value at this cursor position\n     * @param type\n     * @param value\n     */\n    public expectWithValue(type: TokenType, value: string): boolean {\n        if (this.acceptWithValue(type, value)) {\n            return true;\n        }\n        throw new Error('Unexpected token');\n        // todo implement UnexpectedToken error\n        //throw new UnexpectedToken(type, this.getCurrentToken());\n    }\n\n    /**\n     * Expect a token of the given type and with given value at the given offset of this cursor position\n     * @param type\n     * @param offset\n     * @param value\n     */\n    public expectAtWithValue(type: TokenType, offset: number, value: string): boolean {\n        if (this.acceptAtWithValue(type, offset, value)) {\n            return true;\n        }\n        throw new Error('Unexpected token');\n        // todo implement UnexpectedToken error\n        //throw new UnexpectedToken(type, this.getCurrentToken());\n    }\n\n    /**\n     * Point the scope to the last inserted Node\n     */\n    public in() {\n        this.setScope(this.getLastNode());\n    }\n\n    /**\n     * Point the scope to the parent of the current scope\n     */\n    public out() {\n        this.setScope(this.getScope().getParent());\n    }\n\n    /**\n     * Alias of in()\n     */\n    public traverseUp() {\n        this.in();\n    }\n\n    /**\n     * Alias of out()\n     */\n    public traverseDown() {\n        this.out();\n    }\n\n    /**\n     * Get the current scope Node\n     */\n    public getScope(): Node {\n        return this.scope;\n    }\n\n    /**\n     * Get the last inserted Node\n     */\n    public getLastNode(): Node {\n        return this.scope.getChildren()[this.scope.getChildren().length-1];\n    }\n\n    /**\n     * Insert a Node into the current scope\n     * @param node\n     */\n    public insert(node: Node) {\n        node.setParent(this.scope);\n        this.scope.addChild(node);\n    }\n\n    /**\n     * Set the current scope\n     * @param node\n     */\n    private setScope(node: Node) {\n        this.scope = node;\n    }\n\n    /**\n     * Wrap the last inserted Node with another Node, the scope will be the wrapping Node\n     * @param node\n     */\n    public wrap(node: Node) {\n        const last = this.getLastNode();\n        this.getScope().removeLastChild();\n\n        this.insert(node);\n        this.traverseUp();\n\n        this.insert(last);\n    }\n\n    /**\n     * Get the built Abstract Syntax Tree (AST)\n     */\n    public getAst(): AstNode {\n        return this.ast;\n    }\n}","import Lexer from './tokenization/Lexer';\nimport Parser from './parsing/Parser';\n\nexport default class Loom {\n    /**\n     *\n     * @param code\n     */\n    public static make(code: string): string {\n        const tokens = (new Lexer()).tokenize(code);\n        const ast = (new Parser().parse(tokens));\n\n        console.log(ast.getChildren());\n\n        // Simple compiling\n        const output = [];\n\n        tokens.forEach(token => {\n            output.push(token.value);\n        });\n\n        return output.join(' ');\n    }\n}"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,IAAO,kBAAQ;AAAA,EACX,aAAa;AAAA,EACb,cAAc;AAAA,EACd,cAAc;AAAA,EACd,kBAAkB;AAAA,EAClB,eAAe;AAAA,EACf,wBAAwB;AAC5B;;;ACJA,IAAqB,QAArB,MAA2B;AAAA,EAA3B;AAWI;AAAA;AAAA;AAAA;AAAA,SAAQ;AAMR;AAAA;AAAA;AAAA;AAAA,SAAQ,SAAiB;AAMzB;AAAA;AAAA;AAAA;AAAA,SAAQ,kBAA0B;AAMlC;AAAA;AAAA;AAAA;AAAA,SAAQ,OAAe;AAMvB;AAAA;AAAA;AAAA;AAAA,SAAQ,SAAiB;AAMzB;AAAA;AAAA;AAAA;AAAA,SAAQ,YAAoB;AAM5B;AAAA;AAAA;AAAA;AAAA,SAAQ,gBAAwB;AAMhC;AAAA;AAAA;AAAA;AAAA,SAAQ,MAAc;AAMtB;AAAA;AAAA;AAAA;AAAA,SAAQ,SAAsB,CAAC;AAM/B;AAAA;AAAA;AAAA;AAAA,SAAQ,QAAgB;AAMxB;AAAA;AAAA;AAAA;AAAA,SAAQ,YAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAM5B,SAAS,MAA2B;AAEhC,SAAK,SAAS;AACd,SAAK,MAAM,KAAK,OAAO;AAEvB,WAAO,KAAK,SAAS,KAAK,KAAK;AAE3B,WAAK,YAAY,KAAK,OAAO,KAAK,MAAM;AACxC,WAAK,gBAAgB,KAAK,OAAO,KAAK,SAAO,CAAC,KAAK;AAGnD,UAAI,KAAK,sBAAsB;AAC3B,aAAK,OAAO,KAAK,cAAc;AAC/B,aAAK,kBAAkB,KAAK;AAAA,MAChC;AAEA,cAAQ,KAAK,MAAM;AAAA,QACf;AACI,eAAK,SAAS;AACd;AAAA,QACJ;AACI,eAAK,UAAU;AACf;AAAA,QACJ;AACI,eAAK,UAAU;AACf;AAAA,QACJ;AACI,eAAK,WAAW;AAChB;AAAA,QACJ;AACI,eAAK,cAAc;AACnB;AAAA,QACJ;AACI,eAAK,WAAW;AAChB;AAAA,MACR;AAAA,IACJ;AAEA,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKQ,MAAM,sBAA+B,OAAgB;AACzD,UAAM,SAAS,sBAAsB,IAAI;AACzC,WAAO,KAAK,SAAS,UAAU,KAAK;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,gBAAyB;AAG7B,SAAK,QAAQ;AAEb,QAAI,gBAAQ,YAAY,KAAK,KAAK,SAAS,GAAG;AAC1C;AAAA,IACJ;AAEA,QAAI,gBAAQ,uBAAuB,KAAK,KAAK,SAAS,GAAG;AACrD,WAAK,YAAY,KAAK;AACtB;AAAA,IACJ;AAEA,QAAI,gBAAQ,aAAa,KAAK,KAAK,SAAS,GAAG;AAC3C;AAAA,IACJ;AAEA,QAAI,gBAAQ,aAAa,KAAK,KAAK,SAAS,GAAG;AAC3C;AAAA,IACJ;AAEA,QAAI,gBAAQ,cAAc,KAAK,KAAK,SAAS,GAAG;AAC5C;AAAA,IACJ;AAEA,QAAI,gBAAQ,iBAAiB,KAAK,KAAK,SAAS,GAAG;AAC/C;AAAA,IACJ;AAEA;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,WAAW;AAEf,SAAK,SAAS,KAAK;AACnB,SAAK;AAEL,QAAI,CAAE,KAAK,iBAAiB,CAAE,gBAAQ,YAAY,KAAK,KAAK,aAAa,GAAG;AACxE,WAAK,OAAO,KAAK;AAAA,QACb;AAAA,QACA,OAAO,KAAK;AAAA,QACZ,MAAM,KAAK;AAAA,QACX,UAAU,KAAK;AAAA,QACf,KAAK,KAAK,MAAM;AAAA,MACpB,CAAC;AACD,WAAK,UAAU,KAAK,MAAM;AAC1B,WAAK;AAAA,IACT;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,YAAY;AAChB,SAAK,SAAS,KAAK;AACnB,SAAK;AAEL,QAAI,CAAC,KAAK,iBAAiB,CAAC,gBAAQ,aAAa,KAAK,KAAK,aAAa,GAAG;AACvE,WAAK,OAAO,KAAK;AAAA,QACb;AAAA,QACA,OAAO,KAAK;AAAA,QACZ,MAAM,KAAK;AAAA,QACX,UAAU,KAAK;AAAA,QACf,KAAK,KAAK,MAAM;AAAA,MACpB,CAAC;AACD,WAAK,UAAU,KAAK,SAAS,KAAK;AAClC,WAAK;AAAA,IACT;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,YAAY;AAEhB,SAAK;AAEL,SAAK,OAAO,KAAK;AAAA,MACb;AAAA,MACA,OAAO,KAAK;AAAA,MACZ,MAAM,KAAK;AAAA,MACX,UAAU,KAAK;AAAA,MACf,KAAK,KAAK,MAAM;AAAA,IACpB,CAAC;AACD,SAAK;AACL,SAAK;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,aAAa;AACjB,SAAK;AACL,SAAK;AACL,SAAK,SAAS;AACd,SAAK;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,gBAAgB;AACpB,SAAK;AACL,SAAK;AACL,SAAK;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,aAAa;AACjB,SAAK,OAAO,KAAK;AAAA,MACb;AAAA,MACA,OAAO,KAAK;AAAA,MACZ,MAAM,KAAK;AAAA,MACX,UAAU,KAAK;AAAA,MACf,KAAK,KAAK,MAAM;AAAA,IACpB,CAAC;AACD,SAAK;AACL,SAAK;AACL,SAAK;AAAA,EACT;AACJ;;;ACrQA,IAAqB,OAArB,MAAqB,MAAK;AAAA;AAAA;AAAA;AAAA;AAAA,EA8BtB,YAAY,QAAgB,IAAI;AAlBhC;AAAA;AAAA;AAAA;AAAA,SAAU,SAAyB;AAMnC;AAAA;AAAA;AAAA;AAAA,SAAU,WAAmB,CAAC;AAM9B;AAAA;AAAA;AAAA;AAAA,SAAU,aAA6C,CAAC;AAOpD,SAAK,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA,EAKA,UAAkB;AACd,WAAO,KAAK,YAAY;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU,MAAY;AAClB,SAAK,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,YAAkB;AACd,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,WAAmB;AACf,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAAS,OAAe;AACpB,SAAK,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAAS,MAAY;AACjB,SAAK,SAAS,KAAK,IAAI;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc;AACV,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc;AACV,WAAQ,KAAK,SAAS,SAAS;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa,MAAc,OAAuB;AAC9C,SAAK,WAAW,IAAI,IAAI;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,aAAa,MAAwC;AACjD,WAAO,KAAK,WAAW,IAAI,KAAK;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgD;AAC5C,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAkB;AACd,SAAK,SAAS,IAAI;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,SAA0B;AAC5B,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU;AAAA,EAEV;AAAA,EAEA,QAAgB;AAEZ,UAAM,YAAY,CAAC,MAAY,eAAuB,MAAc;AAEhE,YAAM,WAAW,KAAK,QAAQ;AAC9B,YAAM,YAAY,KAAK,SAAS;AAEhC,YAAM,aAAa,KAAK,cAAc;AACtC,YAAM,mBAAmB,CAAC;AAC1B,iBAAW,aAAa,YAAY;AAChC,YAAI,YAAY,WAAW,SAAS;AACpC,YAAI,qBAAqB,OAAM;AAC3B,gBAAM,gBAAgB,UAAU,SAAS;AACzC,sBAAY,GAAG,UAAU,QAAQ,CAAC,GAAG,gBAAgB,IAAI,aAAa,MAAM,EAAE;AAAA,QAClF;AACA,yBAAiB,KAAK,GAAG,SAAS,IAAI,SAAS,EAAE;AAAA,MACrD;AAEA,YAAM,OAAO,eAAe,IAAI,MAAM,OAAO,eAAe,CAAC,IAAI,uBAAQ;AACzE,YAAM,SAAS,CAAC,GAAG,IAAI,GAAG,QAAQ,GAAG,YAAY,IAAI,SAAS,MAAM,EAAE,IAAI,iBAAiB,KAAK,GAAG,CAAC,EAAE;AAEtG,WAAK,YAAY,EAAE,QAAQ,eAAa;AACpC,eAAO,KAAK,UAAU,WAAW,eAAe,CAAC,CAAC;AAAA,MACtD,CAAC;AAED,aAAO,OAAO,KAAK,IAAI;AAAA,IAC3B;AAEA,WAAO,UAAU,IAAI;AAAA,EACzB;AACJ;;;AC1KA,IAAqB,oBAArB,cAA+C,KAAK;AAAA,EAEhD,OAAO,MAAM,QAAyB;AAElC,QAAI,OAAO,uCAAiC,GAAG,GAAG;AAC9C,aAAO,QAAQ,CAAC;AAChB,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA,EAEA,UAAU;AAAA,EAEV;AACJ;;;ACbA,IAAqB,YAArB,MAAqB,mBAAkB,KAAK;AAAA,EAExC,OAAO,MAAM,QAAyB;AAElC,QAAI,OAAO,mCAA+B,OAAO,GAAG;AAChD,aAAO,OAAO,IAAI,WAAU,CAAC;AAC7B,aAAO,WAAW;AAElB,UAAI,OAAO,0BAAsB,GAAG;AAChC,eAAO,aAAa,QAAQ,OAAO,gBAAgB,CAAC;AACpD,eAAO,QAAQ;AAAA,MACnB;AAEA,aAAO,uCAAkC,GAAG;AAC5C,aAAO,QAAQ;AAGf,aACI,kBAAkB,MAAM,MAAM,EACjC;AAED,UAAI,OAAO,uCAAkC,GAAG,GAAG;AAC/C,eAAO,IAAI;AACX,eAAO,QAAQ;AAAA,MACnB;AAEA,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,UAAU;AAAA,EAEV;AACJ;;;ACpCA,IAAqB,UAArB,cAAqC,KAAK;AAAA,EAEtC,OAAO,MAAM,QAAyB;AAElC,WACI,UAAU,MAAM,MAAM,EACzB;AAED,WAAO;AAAA,EACX;AAAA,EAEA,UAAU;AAAA,EAEV;AACJ;;;ACbA,IAAqB,SAArB,MAA4B;AAAA,EAA5B;AAMI;AAAA;AAAA;AAAA;AAAA,SAAQ,SAAiB;AAYzB;AAAA;AAAA;AAAA;AAAA,SAAQ,MAAe,IAAI,QAAQ;AAMnC;AAAA;AAAA;AAAA;AAAA,SAAQ,QAAc,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMpB,MAAM,QAA8B;AAEvC,SAAK,eAAe,MAAM;AAC1B,SAAK,SAAS;AAEd,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,eAAe,QAAqB;AACvC,SAAK,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKQ,WAAW;AAEf,QAAI,CAAE,KAAK,OAAO,QAAQ;AACtB;AAAA,IACJ;AAEA,QAAI,KAAK,SAAU,KAAK,OAAO,SAAO,GAAI;AACtC;AAAA,IACJ;AAEA,QAAI,QAAQ,MAAM,IAAI,GAAG;AACrB,WAAK,SAAS;AAAA,IAClB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKO,kBAAyB;AAC5B,WAAO,KAAK,OAAO,KAAK,MAAM;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,eAAe,QAAuB;AAC1C,WAAO,KAAK,OAAO,KAAK,SAAS,MAAM;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,aAAa,MAAc,QAAiC,MAAM;AACrE,QAAI,UAAU,MAAM;AAChB,cAAQ,KAAK,YAAY;AACzB,WAAK,SAAS,EAAE,gBAAgB;AAAA,IACpC;AACA,SAAK,SAAS,EAAE,aAAa,MAAM,KAAK;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAKO,kBAA0B;AAC7B,WAAO,KAAK,gBAAgB,EAAE;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,QAAQ,SAAiB,GAAG;AAC/B,SAAK,SAAS,KAAK,SAAS;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,OAAO,MAA0B;AACpC,UAAM,QAAQ,KAAK,gBAAgB;AACnC,WAAQ,SAAS,MAAM,SAAS;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,gBAAgB,MAAiB,OAAwB;AAC5D,UAAM,QAAQ,KAAK,gBAAgB;AACnC,WACI,SACA,MAAM,SAAS,QACf,MAAM,UAAU;AAAA,EAExB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,SAAS,MAAiB,QAAyB;AACtD,UAAM,QAAQ,KAAK,eAAe,MAAM;AACxC,WAAQ,SAAS,MAAM,SAAS;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,kBAAkB,MAAiB,QAAgB,OAAwB;AAC9E,UAAM,QAAQ,KAAK,eAAe,MAAM;AACxC,WACI,SACA,MAAM,SAAS,QACf,MAAM,UAAU;AAAA,EAExB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,KAAK,MAA0B;AAClC,QAAI,KAAK,OAAO,IAAI,GAAG;AACnB,WAAK,QAAQ;AACb,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,cAAc,MAAiB,OAAwB;AAC1D,QAAI,KAAK,gBAAgB,MAAM,KAAK,GAAG;AACnC,WAAK,QAAQ;AACb,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,OAAO,MAA0B;AACpC,QAAI,KAAK,OAAO,IAAI,GAAG;AACnB,aAAO;AAAA,IACX;AACA,UAAM,IAAI,MAAM,kBAAkB;AAAA,EAGtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,gBAAgB,MAAiB,OAAwB;AAC5D,QAAI,KAAK,gBAAgB,MAAM,KAAK,GAAG;AACnC,aAAO;AAAA,IACX;AACA,UAAM,IAAI,MAAM,kBAAkB;AAAA,EAGtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,kBAAkB,MAAiB,QAAgB,OAAwB;AAC9E,QAAI,KAAK,kBAAkB,MAAM,QAAQ,KAAK,GAAG;AAC7C,aAAO;AAAA,IACX;AACA,UAAM,IAAI,MAAM,kBAAkB;AAAA,EAGtC;AAAA;AAAA;AAAA;AAAA,EAKO,KAAK;AACR,SAAK,SAAS,KAAK,YAAY,CAAC;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAKO,MAAM;AACT,SAAK,SAAS,KAAK,SAAS,EAAE,UAAU,CAAC;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAKO,aAAa;AAChB,SAAK,GAAG;AAAA,EACZ;AAAA;AAAA;AAAA;AAAA,EAKO,eAAe;AAClB,SAAK,IAAI;AAAA,EACb;AAAA;AAAA;AAAA;AAAA,EAKO,WAAiB;AACpB,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKO,cAAoB;AACvB,WAAO,KAAK,MAAM,YAAY,EAAE,KAAK,MAAM,YAAY,EAAE,SAAO,CAAC;AAAA,EACrE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,OAAO,MAAY;AACtB,SAAK,UAAU,KAAK,KAAK;AACzB,SAAK,MAAM,SAAS,IAAI;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,SAAS,MAAY;AACzB,SAAK,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,KAAK,MAAY;AACpB,UAAM,OAAO,KAAK,YAAY;AAC9B,SAAK,SAAS,EAAE,gBAAgB;AAEhC,SAAK,OAAO,IAAI;AAChB,SAAK,WAAW;AAEhB,SAAK,OAAO,IAAI;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAKO,SAAkB;AACrB,WAAO,KAAK;AAAA,EAChB;AACJ;;;AChTA,IAAqB,OAArB,MAA0B;AAAA;AAAA;AAAA;AAAA;AAAA,EAKtB,OAAc,KAAK,MAAsB;AACrC,UAAM,SAAU,IAAI,MAAM,EAAG,SAAS,IAAI;AAC1C,UAAM,MAAO,IAAI,OAAO,EAAE,MAAM,MAAM;AAEtC,YAAQ,IAAI,IAAI,YAAY,CAAC;AAG7B,UAAM,SAAS,CAAC;AAEhB,WAAO,QAAQ,WAAS;AACpB,aAAO,KAAK,MAAM,KAAK;AAAA,IAC3B,CAAC;AAED,WAAO,OAAO,KAAK,GAAG;AAAA,EAC1B;AACJ;","names":[]}