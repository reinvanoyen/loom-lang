{"version":3,"sources":["../src/index.ts","../src/tokenization/grammar.ts","../src/tokenization/Lexer.ts","../src/parser/Node.ts","../src/parser/nodes/IdentifierType.ts","../src/parser/nodes/StringType.ts","../src/parser/nodes/Type.ts","../src/parser/nodes/VariantDeclaration.ts","../src/parser/nodes/SlotDeclaration.ts","../src/parser/nodes/StyleBlock.ts","../src/binder/Symbol.ts","../src/parser/nodes/Class.ts","../src/parser/nodes/TypeDeclaration.ts","../src/parser/nodes/Namespace.ts","../src/parser/nodes/ImportStatement.ts","../src/parser/AstNode.ts","../src/parser/Parser.ts","../src/compiler/Compiler.ts","../src/compiler/OutputBuffer.ts","../src/binder/Binder.ts","../src/binder/SymbolTable.ts","../src/analyzer/TypeResolver.ts","../src/analyzer/TypeTable.ts","../src/analyzer/DiagnosticReporter.ts","../src/analyzer/TypeChecker.ts","../src/Loom.ts"],"sourcesContent":["import Loom from './Loom';\n\nexport { Loom };","export default {\n    REGEX_IDENT: /\\p{L}/u,\n    REGEX_RAW_BLOCK_START: /{/,\n    REGEX_RAW_BLOCK_END: /}/,\n    REGEX_RAW_BLOCK_INSIDE: /%/,\n    REGEX_NUMBER: /\\d/,\n    REGEX_SYMBOL: /[.!?,;:()\\-+=%*\\\\/—–…${}><&#@°|]/,\n    REGEX_WHITESPACE: /\\s/,\n    REGEX_NEWLINE: /[\\n\\r]/,\n    REGEX_STRING_DELIMITER: /[\"']/,\n    STRING_ESCAPE_SYMBOL: '\\\\',\n};","import grammar from './grammar';\nimport { LexMode, TokenStream, TokenType } from '../types/tokenization';\n\nexport default class Lexer {\n    /**\n     * The source code to tokenize\n     * @private\n     */\n    private source: string = '';\n\n    /**\n     * The current mode of lexing\n     * @private\n     */\n    private mode: LexMode = LexMode.ALL;\n\n    /**\n     * The current position of the cursor\n     * @private\n     */\n    private cursor: number = 0;\n\n    /**\n     * The position of the cursor at the start of the mode\n     * @private\n     */\n    private modeStartCursor: number = 0;\n\n    /**\n     * The current line, starting at line 1\n     * @private\n     */\n    private line: number = 1;\n\n    /**\n     * The current position on the current line, starting at 1\n     * @private\n     */\n    private column: number = 1;\n\n    /**\n     * The current character\n     * @private\n     */\n    private character: string = '';\n\n    /**\n     * The next character, handy for simple look-ahead\n     * @private\n     */\n    private nextCharacter: string = '';\n\n    /**\n     * The index of the last character, also the amount of characters\n     * @private\n     */\n    private end: number = 0;\n\n    /**\n     * The current token stream being created\n     * @private\n     */\n    private tokens: TokenStream = [];\n\n    /**\n     * The current value being lexed\n     * @private\n     */\n    private value: string = '';\n\n    /**\n     * The current delimiter (e.g. string delimiter or boundary)\n     * @private\n     */\n    private delimiter: string = ''\n\n    /**\n     * Transforms code into a TokenStream\n     * @param text\n     */\n    tokenize(text: string): TokenStream {\n\n        this.source = text;\n        this.end = this.source.length;\n\n        while (this.cursor < this.end) {\n\n            this.character = this.source[this.cursor];\n            this.nextCharacter = this.source[this.cursor+1] || '';\n\n            // Determine the mode\n            if (this.mode === LexMode.ALL) {\n                this.mode = this.determineMode();\n                this.modeStartCursor = this.cursor;\n            }\n\n            switch (this.mode) {\n                case LexMode.STRING:\n                    this.lexString();\n                    break;\n                case LexMode.IDENT:\n                    this.lexIdent();\n                    break;\n                case LexMode.RAW_BLOCK:\n                    this.lexRawBlock();\n                    break;\n                case LexMode.NUMBER:\n                    this.lexNumber();\n                    break;\n                case LexMode.SYMBOL:\n                    this.lexSymbol();\n                    break;\n                case LexMode.NEWLINE:\n                    this.lexNewline();\n                    break;\n                case LexMode.WHITESPACE:\n                    this.lexWhitespace();\n                    break;\n                case LexMode.UNKNOWN:\n                    this.lexUnknown();\n                    break;\n            }\n        }\n\n        return this.tokens;\n    }\n\n    /**\n     * @private\n     */\n    private atEnd(accountForDelimiter: boolean = false): boolean {\n        const offset = accountForDelimiter ? 1 : 0;\n        return this.cursor + offset >= this.end;\n    }\n\n    /**\n     * Determines the lexing mode based on the current character\n     * @private\n     */\n    private determineMode(): LexMode {\n\n        // Reset the current token value\n        this.value = '';\n\n        if (\n            grammar.REGEX_RAW_BLOCK_START.exec(this.character) &&\n            grammar.REGEX_RAW_BLOCK_INSIDE.exec(this.nextCharacter)\n        ) {\n            return LexMode.RAW_BLOCK;\n        }\n\n        if (grammar.REGEX_IDENT.exec(this.character)) {\n            return LexMode.IDENT;\n        }\n\n        if (grammar.REGEX_STRING_DELIMITER.exec(this.character)) {\n            this.delimiter = this.character;\n            return LexMode.STRING;\n        }\n\n        if (grammar.REGEX_NUMBER.exec(this.character)) {\n            return LexMode.NUMBER;\n        }\n\n        if (grammar.REGEX_SYMBOL.exec(this.character)) {\n            return LexMode.SYMBOL;\n        }\n\n        if (grammar.REGEX_NEWLINE.exec(this.character)) {\n            return LexMode.NEWLINE;\n        }\n\n        if (grammar.REGEX_WHITESPACE.exec(this.character)) {\n            return LexMode.WHITESPACE;\n        }\n\n        return LexMode.UNKNOWN;\n    }\n\n    /**\n     * Tokenize string\n     * @private\n     */\n    private lexString() {\n\n        const escSequence = (this.character === grammar.STRING_ESCAPE_SYMBOL);\n\n        // String escaping\n        if (escSequence) {\n            this.cursor += 1;\n            // We directly alter the character and nextCharacter,\n            // so we can directly consume them further down in the method\n            this.character = this.source[this.cursor];\n            this.nextCharacter = this.source[this.cursor + 1] || '';\n        }\n\n        if (this.character !== this.delimiter || escSequence) {\n            // Consume the character\n            this.value += this.character;\n        }\n\n        this.cursor++;\n\n        if (this.nextCharacter === this.delimiter) {\n            this.tokens.push({\n                type: TokenType.STRING,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(true),\n            });\n            this.cursor++;\n            this.column += this.cursor - this.modeStartCursor;\n            this.mode = LexMode.ALL;\n            this.delimiter = '';\n        }\n    }\n\n    /**\n     * Tokenize raw block\n     * @private\n     */\n    private lexRawBlock() {\n\n        // If we just entered raw block, skip the opening \"{%\"\n        if (\n            this.value.length === 0 &&\n            grammar.REGEX_RAW_BLOCK_START.exec(this.character) &&      // '{'\n            grammar.REGEX_RAW_BLOCK_INSIDE.exec(this.nextCharacter)    // '%'\n        ) {\n            this.cursor += 2;\n            this.column += 2;\n            return;\n        }\n\n        if (\n            grammar.REGEX_RAW_BLOCK_INSIDE.exec(this.character) &&\n            grammar.REGEX_RAW_BLOCK_END.exec(this.nextCharacter)\n        ) {\n            this.tokens.push({\n                type: TokenType.RAW_BLOCK,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.cursor += 2;\n            this.column += 2;\n            this.mode = LexMode.ALL;\n            return;\n        }\n\n        this.value += this.character;\n        this.cursor++;\n        this.column++;\n    }\n\n    /**\n     * Tokenize identifier\n     * @private\n     */\n    private lexIdent() {\n\n        this.value += this.character;\n        this.cursor++;\n\n        if (! this.nextCharacter || ! grammar.REGEX_IDENT.exec(this.nextCharacter)) {\n            this.tokens.push({\n                type: TokenType.IDENT,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.column += this.value.length;\n            this.mode = LexMode.ALL;\n        }\n    }\n\n    /**\n     * Tokenize number\n     * @private\n     */\n    private lexNumber() {\n        this.value += this.character;\n        this.cursor++;\n\n        if (!this.nextCharacter || !grammar.REGEX_NUMBER.exec(this.nextCharacter)) {\n            this.tokens.push({\n                type: TokenType.NUMBER,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.column += this.cursor - this.modeStartCursor;\n            this.mode = LexMode.ALL;\n        }\n    }\n\n    /**\n     * Tokenize symbol\n     * @private\n     */\n    private lexSymbol() {\n\n        this.cursor++;\n\n        this.tokens.push({\n            type: TokenType.SYMBOL,\n            value: this.character,\n            line: this.line,\n            position: this.column,\n            end: this.atEnd(),\n        });\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n\n    /**\n     * Tokenize newline\n     * @private\n     */\n    private lexNewline() {\n        this.cursor++;\n        this.line++;\n        this.column = 1;\n        this.mode = LexMode.ALL;\n    }\n\n    /**\n     * Tokenize whitespace\n     * @private\n     */\n    private lexWhitespace() {\n        this.cursor++;\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n\n    /**\n     * Tokenize unknown\n     * @private\n     */\n    private lexUnknown() {\n        this.tokens.push({\n            type: TokenType.UNKNOWN,\n            value: this.character,\n            line: this.line,\n            position: this.column,\n            end: this.atEnd(),\n        });\n        this.cursor++;\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n}","import { Nullable } from '../types/nullable';\nimport { AttributeValue } from '../types/attribute';\nimport Parser from './Parser';\nimport Symbol from '../binder/Symbol';\nimport Compiler from '../compiler/Compiler';\nimport Binder from '../binder/Binder';\nimport TypeResolver from '../analyzer/TypeResolver';\nimport TypeChecker from '../analyzer/TypeChecker';\nimport TypeTable from '../analyzer/TypeTable';\nimport chalk from 'chalk';\n\nexport default class Node {\n    /**\n     * @protected\n     */\n    private id: Nullable<number> = null;\n\n    /**\n     * @private\n     */\n    private symbol: Nullable<Symbol> = null;\n\n    /**\n     *\n     * @protected\n     */\n    protected value: Nullable<string> = null;\n\n    /**\n     *\n     * @protected\n     */\n    protected parent: Nullable<Node> = null;\n\n    /**\n     *\n     * @protected\n     */\n    protected children: Node[] = [];\n\n    /**\n     *\n     * @protected\n     */\n    protected attributes: Record<string, AttributeValue> = {};\n\n    /**\n     *\n     * @param value\n     */\n    constructor(value: Nullable<string> = null) {\n        this.value = value;\n    }\n\n    /**\n     * @param id\n     */\n    setId(id: number) {\n        this.id = id;\n    }\n\n    /**\n     *\n     */\n    getId(): Nullable<number> {\n        return this.id;\n    }\n\n    /**\n     * @param symbol\n     */\n    setSymbol(symbol: Symbol) {\n        this.symbol = symbol;\n    }\n\n    /**\n     *\n     */\n    getSymbol() {\n        return this.symbol;\n    }\n\n    /**\n     *\n     */\n    getName(): string {\n        return this.constructor.name;\n    }\n\n    /**\n     *\n     * @param node\n     */\n    setParent(node: Node) {\n        this.parent = node;\n    }\n\n    /**\n     *\n     */\n    getParent(): Nullable<Node> {\n        return this.parent;\n    }\n\n    /**\n     *\n     */\n    getValue(): Nullable<string> {\n        return this.value;\n    }\n\n    /**\n     *\n     * @param value\n     */\n    setValue(value: string) {\n        this.value = value;\n    }\n\n    /**\n     *\n     * @param node\n     */\n    addChild(node: Node) {\n        this.children.push(node);\n    }\n\n    /**\n     *\n     */\n    getChildren() {\n        return this.children;\n    }\n\n    /**\n     *\n     */\n    hasChildren() {\n        return (this.children.length > 0);\n    }\n\n    /**\n     *\n     * @param name\n     * @param value\n     */\n    setAttribute(name: string, value: AttributeValue) {\n        this.attributes[name] = value;\n    }\n\n    /**\n     *\n     * @param name\n     */\n    getAttribute(name: string): Nullable<AttributeValue> {\n        return this.attributes[name] || null;\n    }\n\n    /**\n     *\n     */\n    getAttributes(): Record<string, AttributeValue> {\n        return this.attributes;\n    }\n\n    /**\n     *\n     */\n    removeLastChild() {\n        this.children.pop();\n    }\n\n    /**\n     *\n     * @param _parser\n     */\n    parse(_parser: Parser): boolean {\n        return false;\n    }\n\n    /**\n     *\n     * @param _compiler\n     */\n    compile(compiler: Compiler) {\n        // todo\n    }\n\n    bind(binder: Binder) {\n        this.getChildren().forEach(child => {\n            child.bind(binder);\n        });\n    }\n\n    resolve(typeResolver: TypeResolver) {\n        this.getChildren().forEach(child => {\n            child.resolve(typeResolver);\n        });\n    }\n\n    check(typeChecker: TypeChecker, typeTable: TypeTable) {\n        this.getChildren().forEach(child => {\n            child.check(typeChecker, typeTable);\n        });\n    }\n\n    print(): string {\n\n        const printNode = (node: Node, indentAmount: number = 0): string => {\n\n            const nodeId = node.getId();\n            const nodeName = `${chalk.yellow(node.getName())}`;\n            const nodeValue = node.getValue();\n\n            const attributes = node.getAttributes();\n            const attributesString = [];\n            for (const attribute in attributes) {\n                let attrValue = attributes[attribute];\n                if (attrValue instanceof Node) {\n                    const attrNodeValue = attrValue.getValue();\n                    attrValue = `${attrValue.getName()}${attrNodeValue ? `(${chalk.red(attrNodeValue)})` : ''}`;\n                }\n                attributesString.push(`${chalk.magenta(attribute)}=${chalk.cyan(attrValue)}`);\n            }\n\n            const tabs = indentAmount > 0 ? '   '.repeat(indentAmount - 1) + '└──' : '';\n            const output = [`${chalk.green(nodeId ? nodeId : '-')} ${chalk.grey(tabs)}${nodeName}${nodeValue ? `(${chalk.red(nodeValue)})` : ''} ${attributesString.join(' ')}`];\n\n            node.getChildren().forEach(childNode => {\n                output.push(printNode(childNode, indentAmount + 1));\n            });\n\n            return output.join('\\n');\n        };\n\n        return printNode(this);\n    }\n}","import Node from '../Node';\nimport Binder from '../../binder/Binder';\n\nexport default class IdentifierType extends Node {\n\n    getName(): string {\n        return 'T_IDENT';\n    }\n\n    bind(binder: Binder) {\n\n        const value = this.getValue();\n\n        if (! value) {\n            // todo - do we need to report this?\n            return;\n        }\n\n        if (value === 'string') {\n            // todo - do we need to report this?\n            return;\n        }\n\n        const symbol = binder.getType(value);\n\n        if (! symbol) {\n            // todo - do we need to report this?\n            return;\n        }\n\n        this.setSymbol(symbol);\n    }\n\n    compile() {\n        // todo compile TypeIdentNode\n    }\n}","import Node from '../Node';\n\nexport default class StringType extends Node {\n\n    getName(): string {\n        return 'T_STRING';\n    }\n\n    compile() {\n        // todo compile TypeIdentNode\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport IdentifierType from './IdentifierType';\nimport StringType from './StringType';\nimport Binder from '../../binder/Binder';\n\nexport default class Type extends Node {\n\n    getName(): string {\n        return 'TYPE';\n    }\n\n    /**\n     * @param parser\n     */\n    static parse(parser: Parser): boolean {\n\n        if (parser.expectOneOf([TokenType.IDENT, TokenType.STRING])) {\n\n            parser.insert(new Type());\n            parser.in();\n\n            if (this.parseUnionType(parser)) {\n                parser.out();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    private static parseType(parser: Parser) {\n        if (parser.accept(TokenType.IDENT)) {\n            parser.insert(new IdentifierType(parser.getCurrentValue()))\n            parser.advance();\n            return true;\n        }\n\n        if (parser.accept(TokenType.STRING)) {\n            parser.insert(new StringType(parser.getCurrentValue()))\n            parser.advance();\n            return true;\n        }\n\n        return false;\n    }\n\n    private static parseUnionType(parser: Parser) {\n        if (this.parseType(parser)) {\n            if (parser.skipWithValue(TokenType.SYMBOL, '|')) {\n                this.parseUnionType(parser);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    bind(binder: Binder) {\n        this.getChildren().forEach(child => {\n            child.bind(binder);\n        });\n    }\n\n    compile() {\n        // todo compile VariantDefinition\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport Type from './Type';\nimport TypeChecker from '../../analyzer/TypeChecker';\nimport TypeTable from '../../analyzer/TypeTable';\n\nexport default class VariantDeclaration extends Node {\n\n    getName(): string {\n        return 'VARIANT_DECL';\n    }\n\n    /**\n     * @param parser\n     */\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.SYMBOL,'@')) {\n\n            if (parser.expect(TokenType.IDENT)) {\n                parser.insert(new VariantDeclaration(parser.getCurrentValue()));\n                parser.in();\n                parser.advance();\n\n                if (parser.expectWithValue(TokenType.SYMBOL, ':')) {\n                    parser.advance();\n                }\n\n                Type.parse(parser);\n                parser.setAttribute('type');\n\n                // Parse default value\n                if (parser.skipWithValue(TokenType.SYMBOL, '=')) {\n                    if (parser.expect(TokenType.STRING)) {\n                        parser.setAttribute('default', parser.getCurrentValue());\n                        parser.advance();\n                    }\n                }\n\n                parser.out();\n\n                if (parser.expectWithValue(TokenType.SYMBOL, ';')) {\n                    parser.advance();\n                }\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    check(typeChecker: TypeChecker, typeTable: TypeTable) {\n        //typeChecker.isAssignable(typeTable.getType(this.getAttribute('name')))\n        //console.log(this.getAttribute('default'), typeTable.getType());\n    }\n\n    compile() {\n        // todo compile VariantDefinition\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport Compiler from '../../compiler/Compiler';\n\nexport default class SlotDeclaration extends Node {\n\n    getName(): string {\n        return 'SLOT_DECL';\n    }\n\n    /**\n     * @param parser\n     */\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.IDENT,'slot')) {\n            if (parser.expect(TokenType.IDENT)) {\n                parser.insert(new SlotDeclaration(parser.getCurrentValue()));\n                parser.advance();\n\n                if (parser.expectWithValue(TokenType.SYMBOL, ';')) {\n                    parser.advance();\n                }\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        // todo - register the slot on runtime\n        //compiler.writeLine(`.${this.getValue()} {}`);\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport Compiler from '../../compiler/Compiler';\n\nexport default class StyleBlock extends Node {\n\n    getName(): string {\n        return 'STYLE';\n    }\n\n    /**\n     * @param parser\n     */\n    static parse(parser: Parser): boolean {\n        if (parser.accept(TokenType.RAW_BLOCK)) {\n            parser.insert(new StyleBlock());\n            parser.in();\n            parser.setAttribute('contents', parser.getCurrentValue());\n            parser.advance();\n            parser.out();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        const contents = this.getAttribute('contents');\n\n        if (typeof contents === 'string') {\n            compiler.writeLine('\\t'+contents.trim());\n        }\n    }\n}","import { Namespace } from '../types/namespace';\nimport { Nullable } from '../types/nullable';\n\nexport type SymbolType = 'namespace' | 'class' | 'type' | 'variant' | 'slot';\n\nlet currentId = 0;\n\nexport default class Symbol {\n    /**\n     * @private\n     */\n    private readonly id: number;\n\n    /**\n     * @private\n     */\n    private type: SymbolType;\n\n    /**\n     * @private\n     */\n    private nodeId: number;\n\n    /**\n     * @private\n     */\n    private namespace: Nullable<Namespace> = null;\n\n    /**\n     * @param type\n     * @param nodeId\n     */\n    constructor(type: SymbolType, nodeId: number) {\n        this.id = currentId++;\n        this.type = type;\n        this.nodeId = nodeId;\n    }\n\n    /**\n     */\n    getId(): number {\n        return this.id;\n    }\n\n    /**\n     * @param ns\n     */\n    setNamespace(ns: Namespace) {\n        this.namespace = ns;\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport VariantDeclaration from './VariantDeclaration';\nimport SlotDeclaration from './SlotDeclaration';\nimport StyleBlock from './StyleBlock';\nimport Binder from '../../binder/Binder';\nimport Compiler from '../../compiler/Compiler';\nimport Symbol from '../../binder/Symbol';\nimport TypeResolver from '../../analyzer/TypeResolver';\n\nexport default class Class extends Node {\n\n    getName(): string {\n        return 'CLASS';\n    }\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.IDENT, 'class')) {\n\n            if (parser.expect(TokenType.IDENT)) {\n                parser.insert(new Class(parser.getCurrentValue()));\n                parser.in();\n                parser.advance();\n\n                if (parser.skipWithValue(TokenType.IDENT, 'extends')) {\n                    if (parser.expect(TokenType.IDENT)) {\n                        parser.setAttribute('extends', parser.getCurrentValue());\n                        parser.advance();\n                    }\n                }\n\n                if (parser.expectWithValue(TokenType.SYMBOL, '{')) {\n                    parser.advance();\n                }\n\n                // Parse class body\n                while(\n                    VariantDeclaration.parse(parser) ||\n                    SlotDeclaration.parse(parser) ||\n                    StyleBlock.parse(parser)\n                );\n\n                if (parser.expectWithValue(TokenType.SYMBOL, '}')) {\n                    parser.out();\n                    parser.advance();\n                }\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    bind(binder: Binder) {\n        const id = this.getId();\n        const value = this.getValue();\n\n        if (id && value) {\n            const symbol = new Symbol('class', id);\n            this.setSymbol(symbol);\n            binder.add(value, symbol);\n        }\n    }\n\n    resolve(typeResolver: TypeResolver) {\n        this.getChildren().forEach(child => {\n            child.resolve(typeResolver);\n        });\n    }\n\n    compile(compiler: Compiler) {\n\n        /*\n        // Get current namespace\n        const namespace = compiler.symbols().getNamespace();\n\n        // Build classname\n        const className = `${namespace ? namespace+'-' : '' }${this.getValue()}`;\n\n        // Write CSS :)\n        compiler.writeLine(`.${className} {`);\n\n        this.getChildren().forEach(child => {\n            child.compile(compiler);\n        });\n\n        compiler.writeLine('}');\n        */\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport Type from './Type';\nimport Compiler from '../../compiler/Compiler';\nimport Binder from '../../binder/Binder';\nimport Symbol from '../../binder/Symbol';\nimport TypeResolver from '../../analyzer/TypeResolver';\n\nexport default class TypeDeclaration extends Node {\n\n    getName(): string {\n        return 'TYPE_DECL';\n    }\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.IDENT, 'type')) {\n            if (parser.expect(TokenType.IDENT)) {\n                parser.insert(new TypeDeclaration(parser.getCurrentValue()));\n                parser.in();\n                parser.advance();\n\n                if (parser.expectWithValue(TokenType.SYMBOL, '=')) {\n                    parser.advance();\n                }\n\n                Type.parse(parser);\n\n                parser.out();\n\n                if(parser.expectWithValue(TokenType.SYMBOL, ';')) {\n                    parser.advance();\n                }\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    bind(binder: Binder) {\n\n        const id = this.getId();\n        const value = this.getValue();\n\n        if (id && value) {\n            const symbol = new Symbol('type', id);\n            this.setSymbol(symbol);\n            binder.addType(value, symbol);\n        }\n\n        this.getChildren().forEach(child => child.bind(binder));\n    }\n\n    resolve(typeResolver: TypeResolver) {\n\n        const rhs = this.getChildren().find(child => child instanceof Type) as Type | undefined;\n\n        if (!rhs) {\n            // todo - potentially report this issue through diagnostics?\n            return;\n        }\n\n        const symbol = this.getSymbol();\n\n        if (! symbol) {\n            // todo - potentially report this issue through diagnostics?\n            return;\n        }\n\n        const resolvedType = typeResolver.resolveType(rhs);\n\n        if (! resolvedType) {\n            // todo - potentially report this issue through diagnostics?\n            return;\n        }\n\n        typeResolver.defineType(symbol, resolvedType);\n    }\n\n    compile(compiler: Compiler) {\n        //\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport Compiler from '../../compiler/Compiler';\nimport Binder from '../../binder/Binder';\nimport TypeResolver from '../../analyzer/TypeResolver';\n\nexport default class Namespace extends Node {\n\n    getName(): string {\n        return 'NS';\n    }\n\n    static parse(parser: Parser): boolean {\n        if (parser.skipWithValue(TokenType.IDENT, 'namespace')) {\n\n            if (parser.expect(TokenType.IDENT)) {\n                parser.insert(new Namespace(parser.getCurrentValue()));\n                parser.advance();\n            }\n\n            if (parser.expectWithValue(TokenType.SYMBOL, ';')) {\n                parser.advance();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    bind(binder: Binder) {\n\n        const value = this.getValue();\n\n        if (! value) {\n            return;\n        }\n\n        binder.namespace(value);\n    }\n\n    resolve(typeResolver: TypeResolver) {\n        //typeResolver.namespace(this.getValue());\n    }\n\n    compile(compiler: Compiler) {\n        //compiler.symbols().setNamespace(this.getValue());\n    }\n}","import Node from '../Node';\nimport Parser from '../Parser';\nimport { TokenType } from '../../types/tokenization';\nimport Compiler from '../../compiler/Compiler';\n\nexport default class ImportStatement extends Node {\n\n    getName(): string {\n        return 'IMPORT';\n    }\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.IDENT, 'import')) {\n\n            if (parser.expect(TokenType.STRING)) {\n                parser.expect(TokenType.STRING);\n                parser.insert(new ImportStatement(parser.getCurrentValue()));\n                parser.advance();\n            }\n\n            if (parser.expectWithValue(TokenType.SYMBOL, ';')) {\n                parser.advance();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        // Import\n    }\n}","import Node from './Node';\nimport Parser from './Parser';\nimport Class from './nodes/Class';\nimport TypeDeclaration from './nodes/TypeDeclaration';\nimport Namespace from './nodes/Namespace';\nimport Compiler from '../compiler/Compiler';\nimport ImportStatement from './nodes/ImportStatement';\nimport Binder from '../binder/Binder';\nimport TypeResolver from '../analyzer/TypeResolver';\n\nexport default class AstNode extends Node {\n\n    getName(): string {\n        return 'AST';\n    }\n\n    static parse(parser: Parser): boolean {\n        let parsed = false;\n\n        while(\n            Namespace.parse(parser) ||\n            ImportStatement.parse(parser) ||\n            TypeDeclaration.parse(parser) ||\n            Class.parse(parser)\n        ) {\n            parsed = true;\n        }\n\n        return parsed;\n    }\n\n    compile(compiler: Compiler) {\n        this.getChildren().forEach(child => {\n            child.compile(compiler);\n        });\n    }\n\n    bind(binder: Binder) {\n        this.getChildren().forEach(child => {\n            child.bind(binder);\n        });\n    }\n\n    resolve(typeResolver: TypeResolver) {\n        this.getChildren().forEach(child => {\n            child.resolve(typeResolver);\n        });\n    }\n}","import { Token, TokenStream, TokenType } from '../types/tokenization';\nimport AstNode from './AstNode';\nimport Node from './Node';\nimport { Nullable } from '../types/nullable';\nimport DiagnosticReporter from '../analyzer/DiagnosticReporter';\n\nexport default class Parser {\n\n    /**\n     * The current id\n     * @private\n     */\n    private currentId: number = 0;\n\n    /**\n     * The current position of the cursor\n     * @private\n     */\n    private cursor: number = 0;\n\n    /**\n     * The TokenStream currently being parsed (input)\n     * @private\n     */\n    private tokens: Nullable<TokenStream> = null;\n\n    /**\n     * The Abstract Syntax Tree (AST) currently being build (output)\n     * @private\n     */\n    private ast: AstNode = new AstNode();\n\n    /**\n     * The current scope, which is the Node in which we're currently parser\n     * @private\n     */\n    private scope: Node = this.ast;\n\n    /**\n     * @private\n     */\n    private reporter: DiagnosticReporter;\n\n    /**\n     * @param reporter\n     */\n    constructor(reporter: DiagnosticReporter) {\n        this.reporter = reporter;\n    }\n\n    /**\n     * Parse a TokenStream into an Abstract Syntax Tree (AST)\n     * @param tokens\n     */\n    public parse(tokens: TokenStream): AstNode {\n\n        this.setTokenStream(tokens);\n        this.parseAll();\n\n        return this.ast;\n    }\n\n    /**\n     * Set the TokenStream\n     * @param tokens\n     */\n    public setTokenStream(tokens: TokenStream) {\n        this.tokens = tokens;\n    }\n\n    /**\n     * Parse all tokens in the TokenStream, starting from the cursor position\n     */\n    private parseAll() {\n        if (! this.tokens) {\n            return;\n        }\n\n        while (this.tokens.length && this.cursor <= this.tokens.length - 1) {\n            const before = this.cursor;\n\n            const parsed = AstNode.parse(this);\n\n            // If nothing parsed OR cursor didn't move, consume one token to avoid infinite loops.\n            if (!parsed || this.cursor === before) {\n                const tok = this.getCurrentToken();\n                this.reporter.report({\n                    severity: 'error',\n                    message: `Unexpected token '${tok?.value ?? '<eof>'}'`,\n                });\n                this.advance();\n            }\n        }\n    }\n\n    /**\n     * Get the Token at the cursor position\n     */\n    public getCurrentToken(): Nullable<Token> {\n        if (! this.tokens) {\n            return null;\n        }\n        return this.tokens[this.cursor];\n    }\n\n    /**\n     * Get the Token at the offset of the cursor position\n     * @param offset\n     */\n    private getOffsetToken(offset: number): Nullable<Token> {\n        if (! this.tokens) {\n            return null;\n        }\n        return this.tokens[this.cursor + offset];\n    }\n\n    /**\n     * Set a value as attribute to the current scope Node\n     * If no explicit value was given, the last inserted Node will be used as value\n     * @param name\n     * @param value\n     */\n    public setAttribute(name: string, value: Nullable<string | Node> = null) {\n        if (value === null) {\n            value = this.getLastNode();\n            this.getScope().removeLastChild();\n        }\n        this.getScope().setAttribute(name, value);\n    }\n\n    /**\n     * Get the value of the current token\n     */\n    public getCurrentValue(): Nullable<string> {\n        const token = this.getCurrentToken();\n\n        if (! token) {\n            return null;\n        }\n\n        return token.value;\n    }\n\n    /**\n     * Advance the cursor position by a certain offset\n     * @param offset\n     */\n    public advance(offset: number = 1) {\n        this.cursor = this.cursor + offset;\n    }\n\n    /**\n     * Accept a token of the given type at this cursor position\n     * @param type\n     */\n    public accept(type: TokenType): boolean {\n        const token = this.getCurrentToken();\n        if (! token) {\n            return false;\n        }\n        return (token && token.type === type);\n    }\n\n    /**\n     * Accept a token of the given type and with given value at this cursor position\n     * @param type\n     * @param value\n     */\n    public acceptWithValue(type: TokenType, value: string): boolean {\n        const token = this.getCurrentToken();\n        if (! token) {\n            return false;\n        }\n        return (\n            token &&\n            token.type === type &&\n            token.value === value\n        );\n    }\n\n    /**\n     * Accept a token of the given type at the given offset of this cursor position\n     * @param type\n     * @param offset\n     */\n    public acceptAt(type: TokenType, offset: number): boolean {\n        const token = this.getOffsetToken(offset);\n        if (! token) {\n            return false;\n        }\n        return (token && token.type === type);\n    }\n\n    /**\n     * Accept a token of the given type and with given value at the given offset of this cursor position\n     * @param type\n     * @param offset\n     * @param value\n     */\n    public acceptAtWithValue(type: TokenType, offset: number, value: string): boolean {\n        const token = this.getOffsetToken(offset);\n        if (! token) {\n            return false;\n        }\n        return (\n            token &&\n            token.type === type &&\n            token.value === value\n        );\n    }\n\n    /**\n     * @param types\n     */\n    public acceptOneOf(types: TokenType[]): boolean {\n        const token = this.getCurrentToken();\n        if (! token) {\n            return false;\n        }\n        return (token && types.includes(token.type));\n    }\n\n    /**\n     * Skip a token of the given type at this cursor position\n     * @param type\n     */\n    public skip(type: TokenType): boolean {\n        if (this.accept(type)) {\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Skip the token at this cursor position if it's of the given type and has the given value\n     * @param type\n     * @param value\n     */\n    public skipWithValue(type: TokenType, value: string): boolean {\n        if (this.acceptWithValue(type, value)) {\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Expect a token of the given type at this cursor position\n     * @param type\n     */\n    public expect(type: TokenType): boolean {\n        if (this.accept(type)) {\n            return true;\n        }\n\n        const token = this.getCurrentToken();\n        this.reporter.report({\n            severity: 'error',\n            message: `Expected ${type}, got ${token ? token.type : '?'}`\n        });\n        this.advance();\n        return false;\n    }\n\n    /**\n     * Expect a token of the given type with give value at this cursor position\n     * @param type\n     * @param value\n     */\n    public expectWithValue(type: TokenType, value: string): boolean {\n        if (this.acceptWithValue(type, value)) {\n            return true;\n        }\n\n        const token = this.getCurrentToken();\n        this.reporter.report({\n            severity: 'error',\n            message: `Unexpected token, expected ${type} with value ${value} got ${token ? token.type : '?'} ${token ? token.value : '?'}`\n        });\n        this.advance();\n        return false;\n    }\n\n    /**\n     *\n     * @param types\n     */\n    public expectOneOf(types: TokenType[]): boolean {\n        if (this.acceptOneOf(types)) {\n            return true;\n        }\n\n        this.reporter.report({\n            severity: 'error',\n            message: `Unexpected token, expected one of: ${types.join(', ')}`\n        });\n        this.advance();\n        return false;\n    }\n\n    /**\n     * Point the scope to the last inserted Node\n     */\n    public in() {\n        this.setScope(this.getLastNode());\n    }\n\n    /**\n     * Point the scope to the parent of the current scope\n     */\n    public out() {\n        const scope = this.getScope();\n        const parent = scope.getParent();\n\n        if (! parent) {\n            return;\n        }\n\n        this.setScope(parent);\n    }\n\n    /**\n     * Alias of in()\n     */\n    public traverseUp() {\n        this.in();\n    }\n\n    /**\n     * Alias of out()\n     */\n    public traverseDown() {\n        this.out();\n    }\n\n    /**\n     * Get the current scope Node\n     */\n    public getScope(): Node {\n        return this.scope;\n    }\n\n    /**\n     * Get the last inserted Node\n     */\n    public getLastNode(): Node {\n        return this.scope.getChildren()[this.scope.getChildren().length-1];\n    }\n\n    /**\n     * Insert a Node into the current scope\n     * @param node\n     */\n    public insert(node: Node) {\n        this.assignNewId(node);\n        node.setParent(this.scope);\n        this.scope.addChild(node);\n    }\n\n    /**\n     * @param node\n     * @private\n     */\n    private assignNewId(node: Node) {\n        this.currentId++;\n        node.setId(this.currentId);\n\n    }\n\n    /**\n     * Set the current scope\n     * @param node\n     */\n    private setScope(node: Node) {\n        this.scope = node;\n    }\n\n    /**\n     * Wrap the last inserted Node with another Node, the scope will be the wrapping Node\n     * @param node\n     */\n    public wrap(node: Node) {\n        const last = this.getLastNode();\n        this.getScope().removeLastChild();\n\n        this.insert(node);\n        this.traverseUp();\n\n        this.insert(last);\n    }\n\n    /**\n     * Get the built Abstract Syntax Tree (AST)\n     */\n    public getAst(): AstNode {\n        return this.ast;\n    }\n}","import Node from '../parser/Node';\nimport OutputBuffer from './OutputBuffer';\nimport SymbolTable from '../binder/SymbolTable';\nimport { Nullable } from '../types/nullable';\n\nexport default class Compiler {\n    /**\n     * @private\n     */\n    private readonly symbolTable: Nullable<SymbolTable> = null;\n\n    /**\n     * @private\n     */\n    private readonly buffer: OutputBuffer;\n\n    /**\n     *\n     */\n    constructor(outputBuffer: OutputBuffer) {\n        this.buffer = outputBuffer;\n    }\n\n    /**\n     *\n     */\n    public symbols(): Nullable<SymbolTable> {\n        return this.symbolTable;\n    }\n\n    /**\n     *\n     * @param string\n     */\n    write(string: string) {\n        this.buffer.writeBody(string);\n    }\n\n    writeLine(string: string) {\n        this.buffer.writeBody('\\n'+string);\n    }\n\n    compile(ast: Node) {\n        ast.compile(this);\n        return this.buffer.render();\n    }\n}","export default class OutputBuffer {\n\n    /**\n     *\n     * @private\n     */\n    private head: string[] = [];\n\n    /**\n     *\n     * @private\n     */\n    private body: string[] = [];\n\n    /**\n     *\n     * @private\n     */\n    private foot: string[] = [];\n\n    /**\n     *\n     * @param string\n     */\n    writeBody(string: string) {\n        this.body.push(string);\n    }\n\n    /**\n     *\n     * @param string\n     */\n    writeHead(string: string) {\n        this.head.push(string);\n    }\n\n    /**\n     *\n     * @param string\n     */\n    writeFoot(string: string) {\n        this.foot.push(string);\n    }\n\n    /**\n     *\n     */\n    getHead(): string {\n        return this.head.join('');\n    }\n\n    /**\n     *\n     */\n    getBody(): string {\n        return this.body.join('');\n    }\n\n    /**\n     *\n     */\n    getFoot(): string {\n        return this.foot.join('');\n    }\n\n    render(): string {\n        return this.getHead()+this.getBody()+this.getFoot();\n    }\n}","import Node from '../parser/Node';\nimport Symbol from './Symbol';\nimport SymbolTable from '../binder/SymbolTable';\nimport { Namespace } from '../types/namespace';\nimport DiagnosticReporter from '../analyzer/DiagnosticReporter';\n\nexport default class Binder {\n    /**\n     * @private\n     */\n    private symbolTable: SymbolTable;\n\n    /**\n     * @private\n     */\n    private currentNamespace: Namespace = 'global';\n\n    /**\n     * @private\n     */\n    private reporter: DiagnosticReporter;\n\n    /**\n     * @param reporter\n     * @param symbolTable\n     */\n    constructor(reporter: DiagnosticReporter, symbolTable: SymbolTable) {\n        this.reporter = reporter;\n        this.symbolTable = symbolTable;\n    }\n\n    /**\n     * @param ast\n     */\n    bind(ast: Node) {\n        ast.bind(this);\n    }\n\n    /**\n     * @param ns\n     */\n    namespace(ns: Namespace) {\n        this.currentNamespace = ns;\n    }\n\n    /**\n     * @param name\n     * @param symbol\n     */\n    add(name: string, symbol: Symbol) {\n        if (this.symbolTable.hasSymbol(this.currentNamespace, name)) {\n            this.reporter.report({\n                severity: 'error',\n                message: `Binding error: ${name} already exists`\n            });\n        }\n        this.symbolTable.registerSymbol(this.currentNamespace, name, symbol);\n    }\n\n    /**\n     * @param name\n     */\n    get(name: string) {\n        if (!this.symbolTable.hasSymbol(this.currentNamespace, name)) {\n            this.reporter.report({\n                severity: 'error',\n                message: `Binding error: couldn't get symbol with name ${name}`\n            });\n        }\n        return this.symbolTable.getSymbol(this.currentNamespace, name);\n    }\n\n    // GLOBAL TYPE SPACE\n    addType(name: string, symbol: Symbol) {\n        if (this.symbolTable.hasType(name)) {\n            this.reporter.report({\n                severity: 'error',\n                message: `Binding error: type '${name}' already exists`\n            });\n        }\n        // optional metadata:\n        this.symbolTable.registerType(name, symbol);\n    }\n\n    getType(name: string) {\n        return this.symbolTable.getType(name);\n    }\n}","import { Namespace } from '../types/namespace';\nimport Symbol from '../binder/Symbol';\nimport chalk from 'chalk';\n\nexport default class SymbolTable {\n    private symbols: Record<Namespace, Record<string, Symbol>> = {};\n    private types: Record<string, Symbol> = {}; // global type space\n\n    // --- types (global) ---\n    public registerType(name: string, symbol: Symbol) {\n        this.types[name] = symbol;\n    }\n\n    public hasType(name: string) {\n        return typeof this.types[name] !== 'undefined';\n    }\n\n    public getType(name: string): Symbol | null {\n        return this.types[name] ?? null;\n    }\n\n    // --- values/classes (namespaced) ---\n    public registerSymbol(ns: Namespace, name: string, symbol: Symbol) {\n        if (!this.symbols[ns]) this.symbols[ns] = {};\n        this.symbols[ns][name] = symbol;\n    }\n\n    public hasSymbol(ns: Namespace, name: string) {\n        return !!this.symbols[ns] && typeof this.symbols[ns][name] !== 'undefined';\n    }\n\n    public getSymbol(ns: Namespace, name: string): Symbol | null {\n        return this.symbols[ns]?.[name] ?? null;\n    }\n\n    public print() {\n        const namespaces = Object.keys(this.symbols);\n        namespaces.forEach(ns => {\n            console.log(chalk.bgCyan(`NS: ${ns}`));\n            console.table(this.symbols[ns]);\n        });\n\n        console.log(chalk.bgCyan('GLOBAL TYPES'));\n        console.table(this.types);\n    }\n}","import AstNode from '../parser/AstNode';\nimport TypeTable from './TypeTable';\nimport Type from '../parser/nodes/Type';\nimport { ResolvedType } from '../types/analyzer';\nimport IdentifierType from '../parser/nodes/IdentifierType';\nimport StringType from '../parser/nodes/StringType';\nimport Symbol from '../binder/Symbol';\nimport DiagnosticReporter from './DiagnosticReporter';\nimport { Nullable } from '../types/nullable';\n\ntype TypeChildNode = IdentifierType | StringType;\n\nexport default class TypeResolver {\n    /**\n     * @private\n     */\n    private typeTable: TypeTable;\n\n    /**\n     * @private\n     */\n    private reporter: DiagnosticReporter;\n    \n    /**\n     * @param typeTable\n     */\n    constructor(reporter: DiagnosticReporter, typeTable: TypeTable) {\n        this.reporter = reporter;\n        this.typeTable = typeTable;\n    }\n\n    /**\n     *\n     * @param symbol\n     * @param type\n     */\n    defineType(symbol: Symbol, type: ResolvedType) {\n        this.typeTable.registerType(symbol.getId(), type);\n    }\n\n    /**\n     * @param type\n     */\n    resolveType(type: Type): Nullable<ResolvedType> {\n\n        const children = type.getChildren();\n\n        if (children.length > 1) {\n            return {\n                kind: 'union',\n                members: this.normalizeUnion(children as TypeChildNode[])\n            }\n        }\n\n        if (children.length === 1) {\n            return this.resolveTypeNodeChild(children[0] as TypeChildNode);\n        }\n\n        this.reporter.report({\n            severity: 'error',\n            message: 'TypeResolver error, no types in type?',\n        });\n\n        return null;\n    }\n\n    /**\n     * @param typeChild\n     */\n    private resolveTypeNodeChild(typeChild: TypeChildNode): Nullable<ResolvedType> {\n\n        if (typeChild instanceof IdentifierType) {\n\n            if (typeChild.getValue() === 'string') {\n                return {\n                    kind: 'primitive',\n                    name: 'string'\n                };\n            }\n\n            const symbol = typeChild.getSymbol();\n\n            if (symbol) {\n                return { kind: 'ref', symbolId: symbol.getId() };\n            }\n\n            this.reporter.report({\n                severity: 'error',\n                message: `Unbound type identifier '${typeChild.getValue()}'`,\n            });\n        }\n\n        if (typeChild instanceof StringType) {\n            const value = typeChild.getValue();\n\n            if (value) {\n                return { kind: 'literal', value };\n            }\n\n            // todo - we might want to report this\n            return null;\n        }\n\n        this.reporter.report({\n            severity: 'error',\n            message: 'Unknown type node',\n        });\n\n        return null;\n    }\n\n    /**\n     * @param nodes\n     * @private\n     */\n    private normalizeUnion(nodes: TypeChildNode[]): ResolvedType[] {\n        const resolvedTypes: ResolvedType[] = [];\n\n        nodes.forEach(node => {\n            const resolvedType = this.resolveTypeNodeChild(node);\n\n            if (resolvedType) {\n                resolvedTypes.push(resolvedType);\n            }\n        });\n\n        return resolvedTypes;\n    }\n\n    /**\n     * @param ast\n     */\n    resolve(ast: AstNode) {\n        ast.resolve(this);\n    }\n}","import { Nullable } from '../types/nullable';\nimport { ResolvedType } from '../types/analyzer';\n\nexport default class TypeTable {\n    /**\n     * @private\n     */\n    private types: Record<number, ResolvedType> = {};\n\n    /**\n     * @param symbolId\n     * @param type\n     */\n    public registerType(symbolId: number, type: ResolvedType) {\n        this.types[symbolId] = type;\n    }\n\n    /**\n     * @param symbolId\n     */\n    public hasType(symbolId: number) {\n        return (typeof this.types[symbolId] !== 'undefined');\n    }\n\n    /**\n     * @param symbolId\n     */\n    public getType(symbolId: number): Nullable<ResolvedType> {\n        if (this.hasType(symbolId)) {\n            return this.types[symbolId];\n        }\n        return null;\n    }\n\n    public print() {\n        console.table(this.types);\n    }\n}","type DiagnosticMessage = {\n    severity: 'info' | 'warning' | 'error';\n    message: string;\n    nodeId?: number;\n    // todo - add line/col later (position)\n};\n\nexport default class DiagnosticReporter {\n    /**\n     * @private\n     */\n    private messages: DiagnosticMessage[] = [];\n\n    /**\n     * @param message\n     */\n    public report(message: DiagnosticMessage) {\n        this.messages.push(message);\n    }\n\n    /**\n     *\n     */\n    public hasErrors(): boolean {\n        const errors = this.messages.filter(message => {\n            return message.severity === 'error';\n        });\n\n        return errors.length > 0;\n    }\n\n    public print() {\n        console.table(this.messages);\n    }\n}","import AstNode from '../parser/AstNode';\nimport DiagnosticReporter from './DiagnosticReporter';\nimport TypeTable from './TypeTable';\nimport { ResolvedType } from '../types/analyzer';\n\nexport default class TypeChecker {\n\n    /**\n     * @private\n     */\n    private reporter: DiagnosticReporter;\n\n    /**\n     * @param reporter\n     */\n    constructor(reporter: DiagnosticReporter) {\n        this.reporter = reporter;\n    }\n\n    /**\n     * @param ast\n     */\n    check(ast: AstNode, typeTable: TypeTable) {\n        ast.check(this, typeTable);\n    }\n\n    /**\n     * @param type\n     * @param value\n     */\n    isAssignable(type: ResolvedType, value: string) {\n        return true;\n    }\n}","import Lexer from './tokenization/Lexer';\nimport Parser from './parser/Parser';\nimport Compiler from './compiler/Compiler';\nimport OutputBuffer from './compiler/OutputBuffer';\nimport Binder from './binder/Binder';\nimport SymbolTable from './binder/SymbolTable';\nimport TypeResolver from './analyzer/TypeResolver';\nimport TypeTable from './analyzer/TypeTable';\nimport DiagnosticReporter from './analyzer/DiagnosticReporter';\nimport TypeChecker from './analyzer/TypeChecker';\nimport chalk from 'chalk';\n\nexport default class Loom {\n    /**\n     * @param code\n     */\n    public static make(code: string): string {\n\n        // Make a diagnostics reporter we can report messages to during this whole process\n        const diagnostics = new DiagnosticReporter();\n\n        // Tokenize the code\n        const tokens = (new Lexer()).tokenize(code);\n\n        console.log(chalk.bgGreenBright(' === TOKENS === '));\n        console.log('TOKEN COUNT', tokens.length);\n\n        // Parse the tokens into an AST\n        const ast = (new Parser(diagnostics).parse(tokens));\n        console.log(chalk.bgGreenBright(' === AST === '));\n        console.log(ast.print());\n\n        // Bind Symbols to AST\n        const symbolTable = new SymbolTable();\n        (new Binder(diagnostics, symbolTable)).bind(ast);\n\n        console.log(chalk.bgGreenBright(' === SYMBOL TABLE === '));\n        symbolTable.print();\n\n        // Resolve types\n        const typeTable = new TypeTable();\n        const resolver = new TypeResolver(diagnostics, typeTable);\n        resolver.resolve(ast);\n\n        console.log(chalk.bgGreenBright(' === TYPE TABLE === '));\n        typeTable.print();\n\n        // Check the types\n        // todo - this needs tons of work\n        (new TypeChecker(diagnostics)).check(ast, typeTable);\n\n        console.log(chalk.bgGreenBright(' === DIAGNOSTICS === '));\n        diagnostics.print();\n\n        if (diagnostics.hasErrors()) {\n            console.error('Not compiling, errors found...')\n            return '';\n        }\n\n        // Finally we compile\n        return (new Compiler(new OutputBuffer())).compile(ast);\n    }\n}"],"mappings":"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","names":["chalk","Symbol","Symbol","Symbol","import_chalk","chalk","import_chalk","chalk"]}